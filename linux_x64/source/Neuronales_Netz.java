/* autogenerated by Processing revision 1279 on 2022-01-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.lang.reflect.Field;
import drop.SDrop;
import drop.DropEvent;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Neuronales_Netz extends PApplet {

/*
 * Dies ist ein Beispiel eines Neuronalen Netzes,
 * lernend mithilfe von Backpropagation und mini-batch Optimierung.
 *
 * Programmiert von Jakob Zöphel.
 */

LayerManager lm;
NeuronalNetworkVisualization nv;
Digit digit;
Functions F = new Functions();
//pointer zu der "main" Klasse, für reflections etc.
Neuronales_Netz main = this;
StartScreen panel;
Diagramm diagram;
Console visualConsole;

////////Anfang Parameter können geändert werden////////
public boolean
  show = false,
  train = false,

  loadWeights = false,
  saveWeights = false,

  loadExamples = false,
  saveExamples = false;


//nach wie vielen Minuten das Training unterbrochen werden soll
public int timeOut = 60;

//nach dem die Trainingsbeipsiele durch sind, wird epochs mal von vorne angefangen.
//(ein Durchlauf aller Trainigsbeispiele == eine Epoche)
public int epochs = 100;

//die Anzahl der zu erstellenden Trainingsbeispiele
public int trainExamples = 1000;
//die Anzahl der zu erstellenden Testbeispiele
public int testExamples = 200;

//Anzahl der zu benutzenden Threads. Diese muss am beste gerade sein.
//Maximum: Runtime.getRuntime().availableProcessors()
public int threadCount = 4;

//bestimmt ob die threads anderen gegenüber Vorrang haben.
//1 == niedrigste, 10 == höchste. Standard ist 5
public int threadPriority = 9;

//Größe eines Trainingsstapels
public int batchSize = 4;

//lernrate
public float lr = 0.01f;

//um den Faktor wird das Momentum multipliziert
public float momentumWeakness = 0.8f;

//maximum des Betrages welchen ein Gewicht am Anfang annehmen kann
//(die Gewichte werden am Anfang zufällig gewählt)
public float weigthsValue = 0.02f;

//Anzahl der Layer und die Anzahl ihrer Neuronen
public HiddenL[] hiddenLayers ={
  new HiddenL(8, F.relu),
  new HiddenL(10, F.relu),
};

//mit dieser Funktion wird der Fehler berechnet
public ErrorFunction loss = F.MSE;
//10 Neuronen, eines für jede Ziffer. Aktivierungsfunktion, Fehlerfunktion. Im
//layerManager wird die Anzahl der Neuronen dann auf die charset.length aktualisiert
public OutputLayer outL = new OutputLayer(10, F.sigmoid, loss);

////////Ende Parameter können geändert werden////////
boolean finishedDrawing = false;
boolean showConsole = true;
final int drawWindowSize = 280;
int currEpoch = 0;
int currExample = 0;
float scale = 1;
//ob die Gewichte ge-updated werden sollen
boolean update = false;
//kills threads
boolean kill = false;
//für pooling
int kernel_size = 10;
//starts threads
boolean start = false;
//wenn das Panel auf nichts reagieren soll
boolean ignorePanel = false;
//der Text der in der visuellen Konsole gezeigt wird
ArrayList<String> consoleText = new ArrayList<String>();
int textColor = color(85, 189, 130);
int backgroundColor = color(36, 48, 40);
int contrast = color(56);
//die Aufgabe die das Programm gerade hat
enum Tasks {
  CONTROL_PANEL, AI, DIAGRAM
};

Tasks task;

 public void setup() {

  /* size commented out by preprocessor */;
  task = Tasks.CONTROL_PANEL;
  panel =  new StartScreen();
  //um Bilder in das Fenster zu ziehen
  drop = new SDrop(this);
}

 public void draw() {

  switch(task) {
  case CONTROL_PANEL:
    panel.show();
    break;

  case AI:

    if (train) {

      if (show)
        lm.show();
      else
        panel.show();

      if (currEpoch >= epochs || millis()/1000 >= 60*timeOut) {
        kill = true;
        consoleText.add("Loss in " + epochs + " epochs");
        consoleText.add("(0 = no failures, 1 = only failures)");
        for (int i=0; i < failure.length; i++)
          if (failure[i] == 2)break;
          else consoleText.add("epoch " + i + ": " + failure[i]);

        consoleText.add("minniumum error " + min(failure));
        consoleText.add("milliseconds: " + millis());

        surface.setVisible(true);
        surface.setSize(600, 400);
        diagram = new Diagramm();
        lm.test();
        task = Tasks.DIAGRAM;
      }
    } else {
      ignorePanel = true;
      surface.setTitle("Neural Network");
      translate(width/2, height/2);
      scale(scale);
      translate(-width/2, -height/2);

      if (finishedDrawing && digit.allOutOfScreen) {
        nv.showResult();
        showAnimation();
      }
    }
    break;

  case DIAGRAM:
    diagram.show();
  }
}

//das "eigentliche" setup, wenn das panel fertig ist
 public void setup2() {

  task = Tasks.AI;
  //constrain für Thread-Werte
  threadCount = constrain(threadCount, 0, Runtime.getRuntime().availableProcessors());
  threadPriority = constrain(threadPriority, 0, 10);


  if (train && show)
    surface.setSize(1200, 650);

  if (showConsole && visualConsole == null) {
    String[] args = {"console"};
    visualConsole = new Console();
    PApplet.runSketch(args, visualConsole);
  }

  if (train)
    consoleText.add("Trainiere auf " + threadCount + " Threads.");

  try {
    kill = false;
    start = false;
    lm = new LayerManager();
  }
  catch(Exception e) {
    e.printStackTrace();
    consoleText.add("Ein Fehler ist aufgetreten. Das Programm wird beendet.");
    consoleText.add("Du solltest deine Einstellungen im Control-Panel bearbeiten.");
    noLoop();
  }

  if (show) {
    nv = new NeuronalNetworkVisualization(1200, 600);
    if (train)
      nv.show();

    stroke(255);
    fill(255);
    textSize(21);
    textAlign(CENTER, CENTER);

    if (!train) {
      surface.setVisible(false);
      String[] args2 = {"digit"};
      digit = new Digit();
      PApplet.runSketch(args2, digit);
    }
  } else if (!train) {
    if (testExamples > 0)
      consoleText.add("Erstelle Testbeispiele...");
    loadWeights = true;
    loadExamples = true;
    lm = new LayerManager();
    lm.test();
  }

  if (train && visualConsole != null)
    //start threads
    start = true;
}

 public void showAnimation() {
  int inputSize = (nv.pg.height-2*20)/trainExampleData;
  inputSize = constrain(inputSize, 1, 50);
  for (int i=0; i < digit.pigments.size(); i++) {
    digit.pigments.get(i).show(this, true);
    if (Vdist(digit.pigments.get(i).loc, new PVector(nv.pos[0][digit.pigments.get(i).perceptronIndex].x + nv.offset, nv.pos[0][digit.pigments.get(i).perceptronIndex].y))
      < inputSize || digit.pigments.get(i).loc.x >= nv.pos[0][digit.pigments.get(i).perceptronIndex].x + nv.offset)
      digit.pigments.remove(digit.pigments.get(i));
  }
}

 public static float Vdist(PVector a, PVector b) {
  return dist(a.x, a.y, b.x, b.y);
}

 public void dropEvent(DropEvent event) {
  if (event.isImage()) {
    if (event.filePath() instanceof String)
      //event.loadImage() funktioniert auf Linux nicht :(
      equations = loadImage(event.filePath());
  }
}

 public void crateMNIST(int exmaples, String examplePath) {

  show = false;
  train = false;

  loadWeights = false;
  saveWeights = false;

  loadExamples = false;
  saveExamples = false;
  lm = new LayerManager();

  //namen der Datein
  String[][] names = new String[charset.length][];
  //100, da von jedem Zeichen 100 Beispiele existieren werden
  int totalExamples = exmaples;
  //damit die trainData wieder auf den Ursprung zurück gesetzt werden kann
  byte[][] buffer;

  if (trainData != null)
    buffer = trainData.clone();
  else
    buffer = null;

  trainData = new byte[charset.length*totalExamples][28*28];
  trainExamples = trainData.length;
  trainExampleData = F.createNumber('+').length;


  // um auf die Ordner zugreifen zu können
  File path;

  //welches Bild aus dem Ordner genommen werden soll
  int[] indexes = new int[10];
  for (int i = 0; i < indexes.length; i++)
    indexes[i] = 0;

  for (int i = 0; i < 10; i++) {
    path = new File(examplePath + i);
    names[i] = path.list();
  }

  int alreadyCreated = F.savedExamples();

  for (int i = 0; i < alreadyCreated; i++)
    F.loadExample(i);

  for (int i = alreadyCreated; i < trainData.length; i++) {
    if (i%charset.length <= 9) {

      //was für eine Ziffer
      int type = i%charset.length;
      PImage number = loadImage(examplePath + type + "/" + names[type][indexes[type]]);
      indexes[type]++;
      //MNIST ist weiß mit schwarzen Hintergrund. Das soll umgedreht werden
      number = MNIST_adjustment(number);
      number.resize(drawWindowSize, drawWindowSize);
      number = F.cut(number);
      number = F.pooling(number, kernel_size, (x) -> max(x));
      number = F.blackWhite(number);
      trainData[i] = PApplet.parseByte(F.imageToVector(number));
    } else
      trainData[i] = F.createNumber(charset[i%charset.length]);

    if (i % 100 == 0)
      println(i + "/" + trainData.length);
  }

  lm.saveExamples();

  if (buffer != null)
    //wieder auf Ursprung
    trainData = buffer.clone();
  else
    trainData = null;

  println("finished MNIST");
}

 public PImage MNIST_adjustment(PImage picture) {

  picture.loadPixels();
  for (int i = 0; i < picture.pixels.length; i++)
    if (picture.pixels[i] != color(0))
      picture.pixels[i] = color(255);

  picture.updatePixels();

  picture.loadPixels();
  for (int i = 0; i < picture.pixels.length; i++)
    if (picture.pixels[i] == color(0))
      picture.pixels[i] = color(255);
    else if (picture.pixels[i] == color(255))
      picture.pixels[i] = color(0);

  picture.updatePixels();
  return picture;
}

float e;

 public void mouseWheel(MouseEvent event) {

  panel.mouseWheel(event);

  if (!show)return;
  e = event.getCount();
  scale += e/10;
  scale = constrain(scale, 0.4f, 5);
}

boolean strgIsPressed = false;
boolean keyIsPressed = false;
//bei key kombi's bedeuted ein 's' => 'S'
char key_ = 'S';

 public void keyReleased() {

  panel.keyReleased();

  if (keyCode == CONTROL)
    strgIsPressed = false;
  if (key_ == PApplet.parseChar(keyCode))
    keyIsPressed = false;

  if (keyIsPressed && strgIsPressed) {
    if (!train)
      return;
    if (saveWeights)
      lm.saveWeights();
  }
}

 public void keyTyped() {
  panel.keyTyped();
}

 public void mousePressed() {
  panel.mousePressed();
}

 public void mouseReleased() {
  panel.mouseReleased();
}

boolean spacePressed = false;

 public void keyPressed() {

  panel.keyPressed();

  if (key == ' ')
    spacePressed = !spacePressed;

  if (keyCode == CONTROL && strgIsPressed == false)
    strgIsPressed = true;
  if (key_ == PApplet.parseChar(keyCode))
    keyIsPressed = true;
}

 public String loadFile(String name) {
  return sketchPath("data/"+ name);
}

 public void exit() {
  exitSave();
  super.exit();
}

 public void exitSave() {

  if (saveWeights)
    lm.saveWeights();

  if (saveExamples)
    lm.saveExamples();

  panel.savePanel();
  kill = true;
}
class Console extends PApplet {

  //für scrolling
  int consoleIndex = 0;

   public void settings() {
    size(600, 400);
  }

   public void setup() {
    consoleText.clear();
    surface.setResizable(true);
  }

   public void draw() {
    consoleIndex = constrain(consoleIndex, 0, consoleText.size());

    textSize(21);
    background(contrast);
    fill(textColor);
    textAlign(LEFT, TOP);
    for (int i = consoleIndex; i < consoleText.size(); i++) {

      text(consoleText.get(i), 10, (i-consoleIndex)*25);

      //wenn auch noch gerade trainiert wird
      if (((i+1)-consoleIndex)*25 > height && task != Tasks.DIAGRAM)
        consoleIndex++;
    }
  }

   public void mouseWheel(MouseEvent event) {
    if (consoleText.size() * 25 > height)
      consoleIndex += event.getCount();
  }
   public void exit() {

    if (task == Tasks.AI) {

      kill = true;
      start = false;
      ignorePanel = false;
      task = Tasks.CONTROL_PANEL;
      exitSave();
    }
    visualConsole = null;
  }
}
class Diagramm {

  int rand = 40;
  int offset = 0;
  //Abstand der Messwerte (in Pixeln). g für gap
  int g;
  // von wie vielen Messwerten der Durchschnitt berechnet wird
  int mean = 5;
  //durch den Durchschnitt ist der Graph "smoother"
  float[] smoothFailures;



  Diagramm() {
    surface.setTitle("statistics");
    surface.setResizable(true);
    smoothFailures = new float[failure.length/mean];

    for (int i=0; i < smoothFailures.length; i++)
      smoothFailures[i] = mean(i*mean, mean, failure);
  }

   public void show() {
    background(245);
    //wenn es resized wird
    g = (width-2*rand)/failure.length <= 1 ? 3 : (width-2*rand)/failure.length;

    if (mousePressed) {
      if (mouseButton == RIGHT && offset-10 > -(failure.length/g-1)*g*g+width-2*rand)
        offset -= 10;
      else if (mouseButton == LEFT && offset+10 <= 0)
        offset+=10;
    }
    createDiagram();
  }

   public float mean(int index, int slice, float[] arr) {

    float sum = 0;
    for (int i = 0; i < slice; i++)
      if (i+index >= arr.length)
        return 2;
      else
        sum += arr[i+index];
    return sum/slice;
  }

   public void createDiagram() {

    translate(offset, 0);

    stroke(0, 0, 255);
    noFill();

    beginShape();
    for (int x = 0; x < smoothFailures.length; x++)
      if (smoothFailures[x] != 2)
        vertex(rand+x*g*mean, map(smoothFailures[x], 0, 1, height-rand, rand));
    endShape();

    textAlign(CENTER, CENTER);
    fill(0);
    strokeWeight(1);
    textSize(20);
    text(epochs, rand+(failure.length-1)*g, height-rand+10);
    text((int)epochs/2, (rand+(failure.length-1)*g)/2, height-rand+10);
    text(1, rand-textWidth('1'), rand);
    text("error in per cent", rand/2 + textWidth("error in per cent")/2, rand/2);
    //text("epochs", width-rand, height-rand+10);

    stroke(255, 0, 0, 200);
    noFill();
    beginShape();
    for (int x=0; x < failure.length; x++)
      if (failure[x] != 2)
        vertex(rand+x*g, map(failure[x], 0, 1, height-rand, rand));
    endShape();

    fill(0);
    stroke(0);
    //y
    line(rand, height-rand, rand, rand);
    //x
    line(rand, height-rand, rand+(failure.length-1)*g, height-rand);
  }
}
class Digit extends PApplet {

  final int drawSize = 38;
  float[] example;
  ArrayList<Pixel> pigments= new ArrayList<Pixel>(width*height);//pixels.length

  Digit() {
    super();
  }

   public void settings() {
    size(drawWindowSize, drawWindowSize);
  }

   public void setup() {
    surface.setTitle("please draw a digit");
    background(255);
    fill(0);
    allOutOfScreen = false;
    finishedDrawing = false;
  }

   public void draw() {

    //wenn "again?" gedrückt wird
    if (!mousePressed && !finishedDrawing)
      background(255);

    if (finishedDrawing && !allOutOfScreen)
      animation();
  }

   public void mousePressed() {
    if (train || finishedDrawing) return;
    ellipse(mouseX, mouseY, drawSize, drawSize);
  }

   public void mouseDragged() {
    if (train || finishedDrawing) return;
    ellipse(mouseX, mouseY, drawSize, drawSize);
  }

   public void mouseReleased() {

    if (train || finishedDrawing) return;
    finishedDrawing = true;
    number = F.copyWindowIntoImage(this);
    F.dimImage(number, 80);

    if (mouseButton == RIGHT)rightMouseButtonUsed = true;
    else if (mouseButton == LEFT)rightMouseButtonUsed = false;
    PGraphics number = F.copyWindowIntoPGraphics(this);
    number = F.cut(number);
    //max pooling
    number = F.pooling(number, kernel_size, x -> max(x));
    number = F.blackWhite(number);
    example = PApplet.parseFloat(F.graphicsToVector(number));
    lm.feedForward(example);
    println(charset[PApplet.parseInt(F.max_pool_array(lm.ergebnis))]);

    loadPixels();
    int perceptronIndex = 0;
    for (int y = 0; y < height; y += kernel_size) {
      for (int x = 0; x < width; x += kernel_size) {
        for (int i = x; i < kernel_size + x; i++) {
          for (int j = y; j < kernel_size + y; j++) {
            int pix = index(i, j);
            if (pixels[pix] != color(0) || i%2 == 0 || j%2 == 0 || random(1) > 0.5f|| random(1) > 0.5f) continue;
            else pigments.add(new Pixel(pix%width, pix/height, pixels[pix], perceptronIndex));
          }
        }
        perceptronIndex++;
      }
    }
    updatePixels();
    surface.setLocation(50, 300);

    main.surface.setLocation(600, 100);
    main.surface.setSize(nv.pg.width, nv.pg.height);
    main. surface.setVisible(true);
    nv.showResult();
  }

   public int index(int x, int y) {
    return (x + y * width);
  }

  boolean allOutOfScreen = false;
  int inScreen = 0;
  PImage number;

   public void animation() {

    background(255);
    for (int i=pigments.size()-1; i >= 0; i--)
      if (pigments.get(i).loc.x < width) {
        pigments.get(i).show(this, false);
        inScreen++;
      }
    // if most particles aren't in screen
    if (inScreen < 50) allOutOfScreen = true;
    else inScreen = 0;

    if (!allOutOfScreen) return;
    background(number);

    for (int i=0; i < pigments.size(); i++)
      pigments.get(i).setMovement();
  }

   public void setDigitLocation(int x, int y) {
    surface.setLocation(x, y);
  }

   public void exit() {

    ignorePanel = false;
    //um sicher zu gehem
    if (panel != null)
      panel.state = States.TRAINorSHOW;

    task = Tasks.CONTROL_PANEL;
    main.surface.setSize(1000, 300);
    main.surface.setTitle("control panel");
    //ich weiß noch nicht wie man ein PApplet anhält...
    surface.setVisible(false);
    noLoop();
  }
}
//ScriptEngine wäre kürzer, allerdings kriege ich (neben der Lösung) diesen Output:
//Warning: Nashorn engine is planned to be removed from a future JDK release
//deshalb nutze ich lieber diesen code (was auch sicherer ist als user input auszuführen):

//from https://stackoverflow.com/questions/3422673/how-to-evaluate-a-math-expression-given-in-string-form (9.1.2022, 16:36)
public static double eval(final String str) {
  return new Object() {
    int pos = -1, ch;

     public void nextChar() {
      ch = (++pos < str.length()) ? str.charAt(pos) : -1;
    }

     public boolean eat(int charToEat) {
      while (ch == ' ') nextChar();
      if (ch == charToEat) {
        nextChar();
        return true;
      }
      return false;
    }

     public double parse() {
      nextChar();
      double x = parseExpression();
      if (pos < str.length()) throw new RuntimeException("Unexpected: " + (char)ch);
      return x;
    }

    // Grammar:
    // expression = term | expression `+` term | expression `-` term
    // term = factor | term `*` factor | term `/` factor
    // factor = `+` factor | `-` factor | `(` expression `)`
    //        | number | functionName factor | factor `^` factor

     public double parseExpression() {
      double x = parseTerm();
      for (;; ) {
        if      (eat('+')) x += parseTerm(); // addition
        else if (eat('-')) x -= parseTerm(); // subtraction
        else return x;
      }
    }

     public double parseTerm() {
      double x = parseFactor();
      for (;; ) {
        if      (eat('*')) x *= parseFactor(); // multiplication
        else if (eat('/')) x /= parseFactor(); // division
        else return x;
      }
    }

     public double parseFactor() {
      if (eat('+')) return parseFactor(); // unary plus
      if (eat('-')) return -parseFactor(); // unary minus

      double x;
      int startPos = this.pos;
      if (eat('(')) { // parentheses
        x = parseExpression();
        eat(')');
      } else if ((ch >= '0' && ch <= '9') || ch == '.') { // numbers
        while ((ch >= '0' && ch <= '9') || ch == '.') nextChar();
        x = Double.parseDouble(str.substring(startPos, this.pos));
      } else if (ch >= 'a' && ch <= 'z') { // functions
        while (ch >= 'a' && ch <= 'z') nextChar();
        String func = str.substring(startPos, this.pos);
        x = parseFactor();
        if (func.equals("sqrt")) x = Math.sqrt(x);
        else if (func.equals("sin")) x = Math.sin(Math.toRadians(x));
        else if (func.equals("cos")) x = Math.cos(Math.toRadians(x));
        else if (func.equals("tan")) x = Math.tan(Math.toRadians(x));
        else throw new RuntimeException("Unknown function: " + func);
      } else {
        throw new RuntimeException("Unexpected: " + (char)ch);
      }

      if (eat('^')) x = Math.pow(x, parseFactor()); // exponentiation

      return x;
    }
  }
  .parse();
}
@FunctionalInterface
  public interface Function {

  float f (float x);
}

@FunctionalInterface
  public interface ErrorFunction {
  //einige Funktionen wie z.B. Fehlerfunktionen brauchen mehrere Variablen
  float f(float ... x);
}

class Functions {

  public Function[] relu = {
    //normale Funktion
    x -> x < 0 ?  0 : x,
    //Ableitung der Funktion
    x -> x < 0 ? 0 : 1
  };

  public Function[] sigmoid = {
    x -> Double.valueOf(1/(1+exp(-x))).floatValue(),
    x -> Double.valueOf(1/(1+exp(-x))).floatValue() *
    (1-Double.valueOf(1/(1+exp(-x))).floatValue())
  };

  public Function[] tanh  = {
    x -> (exp(x)-exp(-x))/(exp(x)+exp(-x)),
    x -> 1 - pow((exp(x)-exp(-x))/(exp(x)+exp(-x))-1, 2)
  };

  public Function[] softmax = {
    //das Ergebnis der Funtion wird erst im nachhinein berechnet.
    x -> x,
    x -> x
  };

  public float[] softmax(float[] outputs) {

    for (int i = 0; i < outputs.length; i++)
      outputs[i] = constrain(outputs[i], -30, 30);


    float sum = 0;
    //outptus sind in diesem Fall immer noch das Gleiche wie der netzinput
    for (int i=0; i < outputs.length; i++)
      // epx(88.7) == infinity
      // if (outputs[i] < 86)
      sum += exp(outputs[i]);

    //for (int i=0; i < outputs.length; i++)
    //  if (outputs[i] != outputs[i]) {
    //    printArray(lastOutputs);
    //    printArray(outputs);
    //    println(1);
    //    //System.exit(0);
    //  }

    if (sum == 0) {
      //  sum = 1;
      println("no valid sum");
    }

    for (int i=0; i < outputs.length; i++) {
      float result = exp(outputs[i])/sum;
      if (result != Float.POSITIVE_INFINITY && result != Float.NEGATIVE_INFINITY && result == result && result < 10 && result > -10)
        outputs[i] = exp(outputs[i])/sum;
    }

    return outputs;
  }

  public float[] softmaxAbleitung(float[] netzinput) {

    netzinput = softmax(netzinput);
    for (int i=0; i < netzinput.length; i++)
      netzinput[i] = netzinput[i]-pow(netzinput[i], 2);
    return netzinput;
  }


  //bei den Fehlerfunktionen nur eine,
  //da wir nur die Ableitung brauchen
  //x[0] = ist, x[1] = desired
  public ErrorFunction MSE = x -> x[0] - x[1];

  public ErrorFunction XEntropy = x -> {
    float returnValue = x[1] * Double.valueOf(Math.log(x[0])).floatValue();
    if (returnValue == Float.POSITIVE_INFINITY)
      return 100;
    else if (returnValue == Float.NEGATIVE_INFINITY)
      return -100;
    //wenn es NaN ist, ist das Ergebnis richtig
    else if (returnValue != returnValue)
      return 0;
    return returnValue;
  };

  // ErrorFunction BinaryXEntropy = (x) -> -1 * (-x[1] * Double.valueOf(Math.log(x[0])).floatValue() + (1-x[1]) * Double.valueOf(Math.log(1-x[0])).floatValue());
  public ErrorFunction BinaryXEntropy = x -> {
    float returnValue = -1 * (-x[1] * Double.valueOf(Math.log(x[0])).floatValue() + (1-x[1]) * Double.valueOf(Math.log(1-x[0])).floatValue());
    if (returnValue == Float.POSITIVE_INFINITY)
      return 100;
    else if (returnValue == Float.NEGATIVE_INFINITY)
      return -100;
    //wenn es NaN ist, ist das Ergebnis richtig
    else if (returnValue != returnValue)
      return 0;
    return returnValue;
  };

  //viel Platz für weitere Funktionen, die man wenn man sie braucht hinzufügen kann



   public String Bytes2Bits(byte b) {

    String bits =  String.format("%8s", Integer.toBinaryString(b & 0xFF))
      .replace(' ', '0');
    //127 == 1111111, 128 1000000 etc
    return bits.substring(1, bits.length());
  }

   public byte bits2Bytes(String bitString) {

    byte ret = 0;
    for (int i = 0; i < bitString.length(); i++)
      if (bitString.charAt(i) == '1')
        ret |= 1 << (bitString.length()-1-i);

    return ret;
  }

  //holdingClass ist das Object in dem das gesuchte Field ist
   public String getInstanceName(Object holdingObject, ErrorFunction f) {

    //extract index des Fields
    int number = PApplet.parseInt(split(split(f.toString(), "Lambda$")[1], '/')[0]);
    /*uns interessiert nicht welchen Index das Field hat wenn man
     die publics von main berücksichtigt */
    number -= getLambdaIndex();

    //die Aktivierungsfunktionen sollen nicht berücksichtigt werden
    number -= numberOfLambdaArrays(holdingObject);

    //extrahiere den einfachen Namen
    return split(holdingObject.getClass().getFields()[number].toString(), '.')[1];
  }

   public int numberOfLambdaArrays(Object holdingObject) {

    Field[] fields = holdingObject.getClass().getFields();
    //Anzahl der gefundenen Arrays
    int arrays = 0;

    for (int i = 0; i < fields.length; i++)
      for (int j = 0; j < fields[i].toString().length(); j++)
        // wenn der String ein '[' enthält ist er ein Array
        if (fields[i].toString().charAt(j) == '[') {
          arrays++;
          break;
        }
    return arrays;
  }

   public String getInstanceName(Object holdingObject, Function f) {

    //extract index des Fields
    int number = PApplet.parseInt(split(split(f.toString(), "Lambda$")[1], '/')[0]);
    //uns interessiert nicht welchen Index das Field hat wenn man
    //die publics von main berücksichtigt
    number -= getLambdaIndex();
    //in einem Array sind zwei Funktionen
    number /= 2;

    //extrahiere den einfachen Namen
    return split(holdingObject.getClass().getFields()[number].toString(), '.')[1];
  }

   public int getLambdaIndex() {

    Field[] fields = main.getClass().getFields();
    //nach wie vielen Variablen die von Functions anfangen
    int index = 0;

    for (int i = 0; i < fields.length; i++) {

      //wenn die Variable nich aus dieser Klasse stammt
      if (match(fields[i].toString(), main.getClass().getSimpleName()) == null) {
        index = --i;
        break;
      }
    }
    //für loss was am Anfang initialisiert wird
    index--;
    //für die HiddenLayer Funktionen
    index -= hiddenLayers.length;
    return index;
  }

   public String getValue(String name) {

    for (int i = 0; i < data.length; i++) {
      if (split(data[i], ":::")[0].equals(name))
        return split(data[i], ":::")[1];
    }
    return "";
  }

   public boolean availibleFunction (Object c, String s) {
    Field[] fields = c.getClass().getDeclaredFields();
    for (int i = 0; i < fields.length; i++)
      if (fields[i].getName().equals(s))
        return true;

    return false;
  }

   public int savedExamples() {

    if (examples == null)
      examples = loadBytes(loadFile("examples.txt"));
    return examples.length/(trainExampleData/7);
  }

   public float max_pool_array(float[] array) {
    float a = max(array);
    for (int i=0; i < array.length; i++)
      if (array[i] == a)
        return i;

    //irgendein Fehler, z.B. NaN
    return -1;
  }

   public boolean array_null(byte[] array) {
    for (int i = 0; i < array.length; i++)
      if (array[i] != 0)
        return false;

    return true;
  }

   public byte[] createNumber(char desired) {

    //100 Pixel als Puffer, da die Zahlen in y oft größer sind als drawWindowSize
    PGraphics picture = createGraphics(drawWindowSize, drawWindowSize+100);
    picture.beginDraw();
    picture.textAlign(CENTER, CENTER);
    picture.background(255);
    picture.fill(0);
    picture.stroke(0);
    int size = (int)random(420, 444);
    picture.textSize(size);//400
    PFont font = createFont(fontNames[floor(random(fontNames.length))], size, false, charset);
    picture.textFont(font);

    picture.text(desired, picture.width/2, (picture.height-100)/2);
    picture = F.cut(picture);
    picture = F.pooling(picture, kernel_size, (x) -> max(x));
    picture = F.blackWhite(picture);
    picture.endDraw();

    return PApplet.parseByte(F.graphicsToVector(picture));
  }

   public void loadExample(int index) {
    //ein Trainingsbeispiel  (examples.length*7)/trainExampleData
    for (int j=0; j < trainExampleData/7; j++) {
      String bits = Bytes2Bits(examples[index*(trainExampleData/7)+j]);
      for (int k = 0; k < 7; k++)
        //den char in einen byte convertieren
        trainData[index][j*7+k] = PApplet.parseByte(PApplet.parseInt(str(bits.charAt(k))));
    }
  }

   public void getEquations(PImage picture) {

    //alles was nicht weiß (255) ist, soll schwarz sein
    picture.loadPixels();
    for (int i = 0; i < picture.pixels.length; i++)
      if (picture.pixels[i] != color(255))
        picture.pixels[i] = color(0);
    picture.updatePixels();

    int marginWidth = 1;
    // das Gleiche wie picture nur mit weißen Rändern
    PImage newImage = createImage(picture.width+marginWidth*2, picture.height+marginWidth*2, RGB);

    newImage.loadPixels();
    for (int i = 0; i < newImage.pixels.length; i++)
      newImage.pixels[i] = color(255);

    //Rand einfügen
    for (int x = marginWidth; x < newImage.width-marginWidth; x++)
      for (int y = marginWidth; y < newImage.height-marginWidth; y++)
        newImage.pixels[index1D(x, y, newImage)] =  picture.pixels[index1D(x-marginWidth, y-marginWidth, picture)];

    newImage.updatePixels();
    picture = newImage.get();


    //Positionen der einzelnen Ziffern/Verknüpfungen
    ArrayList<ArrayList<Integer>> posList = new ArrayList<ArrayList<Integer>>();
    //Positionen der einzelnen Gleichungen
    ArrayList<Integer> equationPositions = new ArrayList<Integer>();
    //Bilder der einzelnen Gleichungen
    ArrayList<PImage> equationImages = new ArrayList<PImage>();
    ArrayList<ArrayList<PImage>> pictureList = new ArrayList<ArrayList<PImage>>();


    /*
     zuerst wird das Bild horizontal in Gleichungen geteilt.
     Dazu wird eine neue (erste) Gleichung erstellt
     Die posList enthält dabei Informationen wo die Gleichungen aufhören/anfangen
     */
    pictureList.add(new ArrayList<PImage>());
    posList.add(new ArrayList<Integer>());


    //dort fängt die erste Gleichung an: y=0
    equationPositions.add(0);
    picture.loadPixels();

    //dort wo als letztes ein Bild vermutet wurde
    int lastY = -1;
    //Anzahl an schwarzen Pixeln in einer Reihe
    int pixelCount = 0;
    //Pixelindex von 2D zu 1D
    int index;
    //Bild einer Gleichung
    PImage equation;
    //so viele Pixel sollte ein Strich mindestens haben
    int minPixles = 3;

    for (int y = 0; y < picture.height; y++) {
      //die Anzhal der Pixel in dieser Reihe
      pixelCount = 0;
      for (int x = 0; x < picture.width; x++) {

        index = index1D(x, y, picture);
        if (picture.pixels[index] == color(0))
          pixelCount++;
      }

      //wenn dort viele schwarze Pixel sind und das Bild nicht schon
      //hinzugefügt wurde
      if (pixelCount >= minPixles && y != ++lastY) {

        //neue Gleichung entdeckt, dessen Ziffer-Positionen/Bilder
        //gespeichert werden müssen
        posList.add(new ArrayList<Integer>());
        pictureList.add(new ArrayList<PImage>());
        //dort hört demnach die als letztes entdeckte Gleichung auf
        int posy = equationPositions.get(equationPositions.size()-1);
        //so groß ist die Gleichung
        int yw = y-posy;
        //dort wo die Gleichung anfängt speichern
        equationPositions.add(y);

        //die Gleichung hinzufügen
        equation = createImage(picture.width, yw, RGB);
        equation.copy(picture, 0, posy, picture.width, yw, 0, 0, equation.width, equation.height);
        equationImages.add(equation);

        //damit solange geskippt wird bis die gerade entdeckte Gleichung zuende ist
        lastY = y;
      }
    }

    //dort hört die letzte Gleichung auf
    equationPositions.add(picture.height);
    //letzte Gleichung hinzufügen
    int posy = equationPositions.get(equationPositions.size()-2);
    int yw = equationPositions.get(equationPositions.size()-1)-posy;
    equation = createImage(picture.width, yw, RGB);
    equation.copy(picture, 0, posy, equation.width, yw, 0, 0, equation.width, equation.height);
    equationImages.add(equation);

    //ist immer ein leeres Bild, da es der Rand am Anfang ist
    equationImages.remove(0);

    //eine Ziffer, +, - oder = etc.
    PImage singleNumber;
    //nun werden die entdeckten Gleichungen in die Bestandteile aufgeteilt
    for (int currRow = 0; currRow < equationImages.size(); currRow++) {
      //die zu analysierende Gleichung
      equation = equationImages.get(currRow);

      // da wo der erste Bestandteil anfängt
      posList.get(currRow).add(0);

      equation.loadPixels();

      //das Gleiche wie mit dem Entdecken der Gleichungen, nur nicht horizontal sondern vertikal
      int lastX = -1;
      for (int x = 0; x < equation.width; x++) {
        pixelCount = 0;
        for (int y = 0; y < equation.height; y++) {
          index = index1D(x, y, equation);
          if (equation.pixels[index] == color(0))
            pixelCount++;
        }

        if (pixelCount >= minPixles && x != ++lastX) {
          posList.get(currRow).add(x);
          int posx = posList.get(currRow).get(posList.get(currRow).size()-2);
          int xw = posList.get(currRow).get(posList.get(currRow).size()-1)-posx;

          singleNumber = createImage(xw, equation.height, RGB);
          singleNumber.copy(equation, posx, 0, xw, equation.height, 0, 0, singleNumber.width, singleNumber.height);

          pictureList.get(currRow).add(singleNumber);
          lastX = x;
        }
      }

      int posx = posList.get(currRow).get(posList.get(currRow).size()-1);
      int xw = equation.width-posx;
      singleNumber = createImage(xw, equation.height, RGB);
      singleNumber.copy(equation, posx, 0, xw, equation.height, 0, 0, singleNumber.width, singleNumber.height);
      pictureList.get(currRow).add(singleNumber);
      pictureList.get(currRow).remove(0);

      for (int i = 0; i < pictureList.get(currRow).size(); i++) {
        pictureList.get(currRow).get(i).resize(drawWindowSize, drawWindowSize);
        pictureList.get(currRow).set(i, cut(pictureList.get(currRow).get(i)));
        pictureList.get(currRow).set(i, pooling(pictureList.get(currRow).get(i), kernel_size, x -> max(x)));
        pictureList.get(currRow).set(i, blackWhite(pictureList.get(currRow).get(i)));
      }
      equation.updatePixels();
    }
    //leer
    pictureList.remove(pictureList.size()-1);


    //hier werden später die Gleichungen gespeichert
    String[]computerEquations = new String[pictureList.size()];
    for (int i = 0; i < computerEquations.length; i++)
      computerEquations[i] = "";

    for (int i = 0; i < computerEquations.length; i++) {
      for (int j = 0; j < pictureList.get(i).size(); j++) {
        lm.feedForward(PApplet.parseFloat(imageToVector(pictureList.get(i).get(j))));
        computerEquations[i] += charset[PApplet.parseInt(max_pool_array(lm.ergebnis))];
      }
    }

    int corrects = 0;
    consoleText.clear();
    for (int i = 0; i < computerEquations.length; i++) {
      boolean correctEquation = correct(computerEquations[i]);
      consoleText.add(computerEquations[i] + " " + correctEquation);
      println("equation:", computerEquations[i], correctEquation);
      if (correctEquation)
        corrects++;
    }

    consoleText.add(corrects + "/" + computerEquations.length);
    println(corrects + "/" + computerEquations.length);
  }


   public boolean correct(String equation) {

    try {
      String[] split = split(equation, '=');
      //keine Gleichung
      if (split.length < 2)return false;

      double solution = eval(split[0]);
      for (int i = 1; i < split.length; i++)
        if (eval(split[i]) != solution)
          return false;

      return true;
    }
    catch (Exception e) {
      return false;
    }
  }

  //berechnet die minnimalste Dicke
   public int minXThickness(PImage img) {

    int smallest = img.width;
    int pixelCount;
    int index;
    img.loadPixels();

    for (int y = 0; y < img.height; y++) {
      //die Anzhal der Pixel in dieser Reihe
      pixelCount = 0;
      for (int x = 0; x < img.width; x++) {
        index = index1D(x, y, img);
        while (img.pixels[index] == color(0)) {

          pixelCount++;
          //wenn der Rand kommt, break;
          if (x+1 < img.width)
            x++;
          else
            break;
          index = index1D(x, y, img);
        }
        //wenn Pixel gefunden wurden und es weniger sind als zuvor
        if (pixelCount > 0 && pixelCount < smallest)
          smallest = pixelCount;
      }
    }
    img.updatePixels();
    return smallest;
  }

   public int index1D(int x, int y, PImage image) {
    return x + y * image.width;
  }

   public PVector index2D(int i, PImage image) {
    return new PVector(i%image.width, PApplet.parseInt(i/image.width));
  }

   public PImage cut(PImage original) {

    int[] margins =  getMargins(original);
    //rand x oben, rand x unten, rand y links, rand y rechts
    int rx0 = margins[0], rx1 = margins[1];
    int ry0 = margins[2], ry1 = margins[3];

    //copy des pictures
    PImage pic = createImage(drawWindowSize, drawWindowSize, RGB);
    pic.loadPixels();
    for (int i = 0; i < pic.pixels.length; i++)
      pic.pixels[i] = color(255);
    pic.updatePixels();


    int resize = 0;
    if (drawWindowSize-(rx1-rx0) < drawWindowSize-(ry1-ry0))
      resize = drawWindowSize-(rx1-rx0);
    else
      resize = drawWindowSize-(ry1-ry0);


    //kopieren der Zahl
    int sizex = (rx1-rx0)+resize;
    int sizey = (ry1-ry0)+resize;
    int offsetx = drawWindowSize/2 - sizex/2;
    int offsety = drawWindowSize/2 - sizey/2;

    //pic.copy(original, rx0, ry0, rx1-rx0, ry1-ry0, pic.width/2-(rx1-rx0)/2-resize/2, pic.height/2-(ry1-ry0)/2-resize/2, rx1-rx0+resize, ry1-ry0+resize);
    pic.copy(original, rx0, ry0, rx1-rx0, ry1-ry0, //stimmt
      offsetx, offsety, sizex, sizey);
    return pic;
  }

   public PGraphics cut(PGraphics picture) {

    int[] margins =  getMargins(picture);
    //rand x oben, rand x unten, rand y links, rand y rechts
    int rx0 = margins[0], rx1 = margins[1];
    int ry0 = margins[2], ry1 = margins[3];


    //ein PGraphics das die Größe des Fensters hat
    PGraphics returnPicture = createGraphics(drawWindowSize, drawWindowSize);

    //damit das Bild immer bis zum Rand geht (einheitlicher)
    int resize = 0;
    if (drawWindowSize-(rx1-rx0) < drawWindowSize-(ry1-ry0))
      resize = drawWindowSize-(rx1-rx0);
    else
      resize = drawWindowSize-(ry1-ry0);


    int sizex = (rx1-rx0)+resize;
    int sizey = (ry1-ry0)+resize;
    int offsetx = drawWindowSize/2 - sizex/2;
    int offsety = drawWindowSize/2 - sizey/2;

    //kopieren der Zahl
    returnPicture.beginDraw();
    returnPicture.background(255);
    //nicht nach Maßstab
    // returnPicture.copy(pic, rx0, ry0, rx1-rx0, ry1-ry0, 0, 0, drawWindowSize, drawWindowSize);
    returnPicture.copy(picture.get(), rx0, ry0, rx1-rx0, ry1-ry0,
      offsetx, offsety, sizex, sizey);
    returnPicture.endDraw();

    return returnPicture;
  }

   public int[] getMargins(PImage picture) {

    //rand x oben, rand x unten, rand y links, rand y rechts
    int rx0 = 0, rx1 = 0, ry0 = 0, ry1 = 0;

    //von oben nach unten
    for (int y = 0; y < picture.height; y++) {
      for (int x = 0; x < picture.width; x++) {
        //wenn dort die Ziffer beginnt
        if (color(picture.get(x, y)) == color(0)) {
          ry0 = y;
          break;
        }
      }
      if (ry0 != 0)
        break;
    }

    //von unten nach oben
    for (int y = picture.height-1; y >= 0; y--) {
      for (int x = 0; x < picture.width; x++) {
        //wenn dort die Ziffer beginnt
        if ((int)picture.get(x, y) == color(0)) {
          ry1 = y;
          break;
        }
      }
      if (ry1 != 0)
        break;
    }

    //von links nach rechts
    for (int x = 0; x < picture.width; x++) {
      for (int y = 0; y < picture.height; y++) {
        //wenn dort die Ziffer beginnt
        if ((int)picture.get(x, y) == color(0)) {
          rx0 = x;
          break;
        }
      }
      if (rx0 != 0)
        break;
    }

    //von rechts nach links
    for (int x = picture.width-1; x >= 0; x--) {
      for (int y = 0; y < picture.height; y++) {
        //wenn dort die Ziffer beginnt
        if ((int)picture.get(x, y) == color(0)) {
          rx1 = x;
          break;
        }
      }
      if (rx1 != 0)
        break;
    }

    int[] margins = {rx0, rx1, ry0, ry1};
    return margins;
  }

   public PGraphics copyWindowIntoPGraphics(PApplet p) {

    PGraphics r = createGraphics(p.width, p.height);
    r.beginDraw();
    r.loadPixels();
    p.loadPixels();
    for (int i=0; i < r.pixels.length; i++) {
      r.pixels[i]  = p.pixels[i];
    }

    p.updatePixels();
    r.updatePixels();
    r.endDraw();
    return r;
  }

   public PImage copyWindowIntoImage(PApplet p) {

    PImage r = createImage(p.width, p.height, RGB);
    r.loadPixels();
    p.loadPixels();
    for (int i=0; i < r.pixels.length; i++) {
      r.pixels[i]  = p.pixels[i];
    }

    p.updatePixels();
    r.updatePixels();
    return r;
  }

  //funktioniert nur für schwarz weiß Bilder
   public PImage dimImage(PImage img, int amount) {

    img.loadPixels();
    for (int i = 0; i < img.pixels.length; i++) {
      if (img.pixels[i] == color(255))
        continue;
      //  float r = red(img.pixels[i])-amount;
      //  float g = green(img.pixels[i])-amount;
      //  float b = blue(img.pixels[i])-amount;
      //  img.pixels[i] = color(r,g,b);
      img.pixels[i] = color(amount);
    }
    img.updatePixels();

    return img;
  }

   public int[] copyWindowIntoVector() {

    int[]  r = new int [width * height];
    loadPixels();
    for (int i=0; i < r.length; i++) {
      r[i]  = pixels[i];
    }
    updatePixels();
    return r;
  }

   public int[] imageToVector(PImage img) {

    img.loadPixels();
    int[] vector = new int[img.width*img.height];
    for (int i = 0; i < vector.length; i++)
      // x = byte(color(x))
      vector[i] = PApplet.parseByte(img.pixels[i]);

    img.updatePixels();
    return vector;
  }

   public int[] graphicsToVector(PGraphics img) {

    img.beginDraw();
    img.loadPixels();
    int[] vector = new int[img.width*img.height];
    for (int i = 0; i < vector.length; i++)
      // x = byte(color(x))
      vector[i] = PApplet.parseByte(img.pixels[i]);

    img.updatePixels();
    img.endDraw();
    //return byte(img.pixels)
    return vector;
  }

   public PGraphics pooling(PGraphics image, int kernel_size, ErrorFunction pool) {

    PGraphics returnGraphic = createGraphics(image.width/kernel_size, image.height/kernel_size);
    returnGraphic.beginDraw();
    float r = 0;
    float g = 0;
    float b = 0;
    int f = 0;
    image.loadPixels();
    returnGraphic.loadPixels();
    for (int y = 0; y < image.height; y += kernel_size) {
      for (int x = 0; x < image.width; x += kernel_size) {

        for (int i = x; i < kernel_size + x; i++) {
          for (int j = y; j < kernel_size + y; j++) {
            int pix = index1D(i, j, image);
            //es wird zwar kein Fehler berechnet, aber das Interface ErrorFunction
            //kann mehrere Werte annehmen...
            r = pool.f(red(image.pixels[pix]), r);
            g = pool.f(green(image.pixels[pix]), g);
            b = pool.f(blue(image.pixels[pix]), b);
          }
        }

        returnGraphic.pixels[f] = color(r, g, b);
        f++;
        r = 0;
        g = 0;
        b = 0;
      }
    }
    returnGraphic.updatePixels();
    returnGraphic.endDraw();
    image.updatePixels();
    return returnGraphic;
  }

   public PImage pooling(PImage image, int kernel_size, ErrorFunction pool) {

    PImage returnImage = createImage(image.width/kernel_size, image.height/kernel_size, RGB);
    float r = 0;
    float g = 0;
    float b = 0;
    int f = 0;
    image.loadPixels();
    returnImage.loadPixels();
    for (int y = 0; y < image.height; y += kernel_size) {
      for (int x = 0; x < image.width; x += kernel_size) {

        for (int i = x; i < kernel_size + x; i++) {
          for (int j = y; j < kernel_size + y; j++) {
            int pix = index1D(i, j, image);
            //es wird zwar kein Fehler berechnet, aber das Interface ErrorFunction
            //kann mehrere Werte annehmen...
            r = pool.f(red(image.pixels[pix]), r);
            g = pool.f(green(image.pixels[pix]), g);
            b = pool.f(blue(image.pixels[pix]), b);
          }
        }

        returnImage.pixels[f] = color(r, g, b);
        f++;
        r = 0;
        g = 0;
        b = 0;
      }
    }
    returnImage.updatePixels();
    image.updatePixels();
    return returnImage;
  }

   public PImage blackWhite(PImage picture) {
    picture.loadPixels();
    for (int i = 0; i < picture.pixels.length; i++)
      picture.pixels[i] = blackWhite(picture.pixels[i]);
    picture.updatePixels();

    return picture;
  }

   public PGraphics blackWhite(PGraphics picture) {
    picture.beginDraw();
    picture.loadPixels();
    for (int i = 0; i < picture.pixels.length; i++)
      picture.pixels[i] = blackWhite(picture.pixels[i]);
    picture.updatePixels();
    picture.endDraw();

    return picture;
  }

  //blackWhite passt den Wert für das Netz etwas an
   public int blackWhite(int c) {
    //welcher Wert nun für welche Farbe steht ist egal, Hauptsache
    //sie sind unterschiedlich
    int a = color(1);
    if (c == color(0))
      a = color(0);
    return a;
  }

   public PImage convolution(PImage img, float[][] kernel_weights) {

    PImage filtered = createImage(img.width-2, img.height-2, RGB);
    filtered.loadPixels();
    img.loadPixels();
    int index1D = 0;
    for (int y = 1; y < img.height-1; y++) {
      for (int x = 1; x < img.width-1; x++) {
        int rgb = calculateConv(img, x, y, kernel_weights);
        //int pix = index1D(x, y, img);
        filtered.pixels[index1D] = rgb;
        index1D++;
      }
    }
    img.updatePixels();
    filtered.updatePixels();
    return filtered;
  }

   public int calculateConv(PImage img, int x, int y, float[][] kernel_weights) {

    int sumR = 0;
    int sumG = 0;
    int sumB = 0;

    for (int i = -1; i < 2; i++) {
      for (int j = -1; j < 2; j++) {

        int pix = index1D(x + i, y + j, img);
        float filter = kernel_weights[j + 1][i + 1];

        sumR += red(img.pixels[pix]) * filter;
        sumG += green(img.pixels[pix]) * filter;
        sumB += blue(img.pixels[pix]) * filter;
      }
    }
    return color(sumR, sumG, sumB);
  }
}
class HiddenL {

  HiddenN[] hiddenNs;
  HiddenL(int numberOfPerceptrons, Function[] func) {
    //Array aus Neuronen, die die Schicht hat
    hiddenNs = new HiddenN[numberOfPerceptrons];
    for (int i=0; i < numberOfPerceptrons; i++)
      hiddenNs[i] = new HiddenN(func);
  }

   public void createWeights(int numberOfWeigths) {
    for (int i=0; i < hiddenNs.length; i++) {
      hiddenNs[i].createWeights(numberOfWeigths);
    }
  }
}

class HiddenN extends Functions {

  float[] weights, meanweights;
  float[] summe = new float[2];
  float bias, meanBias, loss, sum, momentum;
  Function[] function;

  HiddenN(Function[] function_) {
    function = function_;
  }

   public void createWeights(int numberOfWeigths) {
    weights= new float[numberOfWeigths];
    meanweights= new float[numberOfWeigths];
  }

   public float feedForward(float[] input) {
    
    sum = 0;
    for (int i = 0; i < weights.length; i++) {
      sum += weights[i] * input[i];
    }
    sum += bias;
    return sum;
  }

  //aj sind die Outputs der Neurons aus der Schicht davor, hier die Input-schicht
   public float backward(int neuronNumber, float[] deltaList, float netzinput, float[] aj, int layerNumber) {
    
    loss = 0;
    //wenn es die letzte Schicht ist
    if (layerNumber == hiddenLayers.length-1) {
      for (int i = 0; i < outL.outNs.length; i++) {
        //deltaList ist ein Array aus dem loss der einzelnen Outputneuronen
        loss += deltaList[i] * outL.outNs[i].weightsOH[neuronNumber];
      }
    } else {
      for (int i = 0; i < hiddenLayers[layerNumber+1].hiddenNs.length; i++) {
        loss += deltaList[i] * hiddenLayers[layerNumber+1].hiddenNs[i].weights[neuronNumber];
      }
    }
    loss *= function[1].f(netzinput);
    for (int i = 0; i < weights.length; i++) {
      meanweights[i] += loss * lr * aj[i];
    }
    meanBias += lr * loss;

    return loss;
  }
  
   public void reset_own_weights() {
    for (int i=0; i < weights.length; i++) weights[i] = random(-weigthsValue, weigthsValue);
  }

   public void applyBatch() {
    
    for (int i = 0; i < weights.length; i++) {
      momentum += meanweights[i];
      //der Betrag der Gewichtsänderung hängt damit auch davon ab, wie hoch er in den Durchläufen davor war. Dieser Einfluss nimmt aber ab.
      momentum *= momentumWeakness;
      weights[i] += meanweights[i] + momentum;
      meanweights[i] = 0;
    }
    bias += meanBias + momentum;
    meanBias = 0;
  }
}
class OutputLayer {

  OutN[] outNs;

  OutputLayer(int numberOfPerceptrons, Function[] function_, ErrorFunction error_) {

    outNs = new OutN[numberOfPerceptrons];
    for (int i = 0; i < outNs.length; i++) {
      outNs[i] = new OutN(function_, error_);
    }
  }
}

class OutN extends Functions {

  float[] weightsOH, meanWeightsOH;// OH da es die Verbindung zwischen -O-utput und -H-idden Layer ist
  float[] summe = new float[2];
  float bias, meanBias, sum, loss, desired, momentum;
  Function[] function;
  ErrorFunction error;

  OutN(Function[] function_, ErrorFunction error_) {
    this.function = function_;
    this.error = error_;
    weightsOH = new float[hiddenLayers[hiddenLayers.length-1].hiddenNs.length];
    meanWeightsOH= new float[weightsOH.length];
  }

   public float feedForward(float[] input) {
    
    sum = 0;
    for (int i = 0; i < weightsOH.length; i++) {
      sum += weightsOH[i] * input[i];
    }
    sum += bias;
    return sum;
  }

  //aj sind die Outputs der Neurons aus der Schicht davor, hier die Hidden-schicht
   public float backward(int numberOfNeuron, int label, float ist, float netzinput, float[] aj) {
    
    if (numberOfNeuron == label)
      desired = 1;
    else
      desired = 0;

    loss = error.f(ist, desired) * function[1].f(netzinput);

    for (int i = 0; i < weightsOH.length; i++) {
      meanWeightsOH[i] += lr * loss * aj[i];
    }
    meanBias += lr * loss;
    return  loss;
  }
  
   public void reset_own_weights() {
    for (int i=0; i < weightsOH.length; i++)
      weightsOH[i] = random(-weigthsValue, weigthsValue);
  }

   public void applyBatch() {
    
    for (int i = 0; i < weightsOH.length; i++) {
      momentum +=  meanWeightsOH[i];
      //der Betrag der Gewichtsänderung hängt damit auch davon ab, wie hoch er in den Durchläufen davor war. Dieser Einfluss nimmt aber ab.
      momentum *= momentumWeakness;
      weightsOH[i] += meanWeightsOH[i] + momentum;
      meanWeightsOH[i] = 0;
    }
    bias += meanBias + momentum;
    meanBias = 0;
  }
}
boolean rightMouseButtonUsed = false;

class Pixel {
  PVector loc;
  int c;
  //the perceptron it will move towards
  int perceptronIndex;
  PVector vel;

  Pixel(int x, int y, int c, int perceptronIndex_) {
    loc = new PVector(x, y);
    this.perceptronIndex = perceptronIndex_;
    this.c = c;
    vel = new PVector(random(1, 2), random(-2, 2));
    vel.setMag(1);
  }

   public void show(PApplet p, boolean changeColor) {

    if (changeColor)
      p.stroke(changeColor(c));
    else
      p.stroke(c);
    p.point(loc.x, loc.y);
    //p.rect(loc.x, loc.y, 2,2);
    loc.add(vel);
  }

   public void setMovement() {
    loc.set(0, height/2);
    vel.set(new PVector(nv.pos[0][perceptronIndex].x + nv.offset, nv.pos[0][perceptronIndex].y).sub(loc));
    if (rightMouseButtonUsed)
      vel.setMag(4);
    else
      vel.setMag(vel.mag()/50);
  }

   public int changeColor(int col_) {
    if (col_ == -1)
      return color(0);
    else
      return color(255);
  }
}




SDrop drop;
//das Bild der Gleichungen
PImage equations;
//Größe der Navigier-Pfeile
int arrowSize = 3;

enum States {


  TRAINorSHOW, LAYERS, VARIABLES, RUN;

   public static States lastState(States state) {

    //index des States
    int index = getIndex(state);

    if (getState(index-1) != null)
      return values()[index-1];
    else
      return state;
  }

   public static States nextState(States state) {

    //index des States
    int index = getIndex(state);

    if (getState(index+1) != null)
      return values()[index+1];
    else
      return state;
  }

   public static States getState(int i) {
    if (i < values().length && i >= 0)
      return values()[i];
    else
      return null;
  }

   public static int getIndex(States state) {
    for (int i = 0; i < values().length; i++)
      if (state == values()[i])
        return i;

    return -1;
  }
};

String[] data;
// Path von diesem file
String path;

class StartScreen {

  TextField[] text = new TextField[16];
  ArrayList<TextField> layerFields;

  //Abstand zu anderen Elementen
  static final int rand = 20;
  int x, y;
  int sizex, sizey;
  //Abstand der Layerübersicht zu y = 0
  int layerOffset = 100;
  //scrolling
  float wheel = 0;
  String methodNameText, methodNameTextError;
  //hier sind z.B. die help-strings etc.
  String[] helpDocumentation;

  States state;
  //um die Funktionen festzulegen
  TextField errorFunctionField;
  TextField outputFunctionField;

  StartScreen() {

    helpDocumentation = loadStrings(loadFile("help.txt"));
    data = loadStrings(loadFile("data.txt"));
    surface.setTitle("control panel");
    x = width-2*rand;
    y = height-2*rand;
    //6 Felder jedes y
    sizex = x/6-rand;
    //3 Felder für jedes x
    sizey = y/3-rand;

    layerFields = new ArrayList<TextField>();

    int numberOfLayers = 0;
    for (int i = 0; i < data.length; i++) {
      String string = split(data[i], ":::")[0];
      if (string.substring(1, string.length()).equals("hiddenLayers"))
        numberOfLayers++;
    }

    for (int i = 0; i < numberOfLayers; i++) {
      Object value;
      //wenn es noch nicht gespeichert wurde
      if (F.getValue(i + "hiddenLayers").length() == 0) {
        if (hiddenLayers.length > i) {
          value =  hiddenLayers[i].hiddenNs.length + ":relu";
        } else
          value = ":";
      } else
        value = F.getValue(i + "hiddenLayers");

      layerFields.add(new TextField(width/2-sizex, layerOffset+i*sizey/2, sizex*2, sizey/2,
        "[HiddenL", "hiddenLayers", value));
    }


    Class mainClass = main.getClass();
    Field[] allVariables = mainClass.getFields();
    Field[] variables = new Field[text.length];

    for (int i = 0; i < variables.length; i++)
      //vieleicht wenn es nicht protected ist??
      variables[i] = allVariables[i];

    //nur public Variablen sind in dem Array, welche geändert werden dürfen
    for (int i = 0; i < text.length; i++)
    try {
      //wird sowieso weg optimiert, sieht aber schöner aus
      int posx = i*(sizex+rand);
      Object value;
      String name = variables[i].getName();

      if (F.getValue(name).equals(""))
        value = variables[i].get(main);
      else
        value = F.getValue(name);

      text[i] = new TextField((posx+rand)%x, (PApplet.parseInt(posx/x)*(sizey+rand)+rand)%y, sizex, sizey,
        variables[i].getType().toString(), name, value);
    }
    catch(IllegalAccessException e) {
      consoleText.add("Einige Variablen wurden gelöscht. Das Programm wird beendet.");
      e.printStackTrace();
      noLoop();
    }

    for (TextField f : text)
      f.ignore = true;

    state =  States.TRAINorSHOW;

    Field[] methods = F.getClass().getFields();
    //-1 da das letzte Element Functions.this ist
    String[] methodNames = new String[methods.length-1];
    String[] methodTypes = new String[methods.length-1];
    for (int i = 0; i < methodNames.length; i++) {
      methodNames[i] = split(split(methods[i].toString(), '$')[2], '.')[1];
      methodTypes[i] = split(split(methods[i].toString(), '$')[1], ' ')[0];
    }

    // Info welche Funktionen verfügbar sind (Aktivierung, Fehler)
    methodNameText = "";
    methodNameTextError = "";
    String value;

    //wenn es nicht gespeichert ist
    if (F.getValue("errorFunction").length() == 0)
      value = F.getInstanceName(F, loss);
    else
      value = F.getValue("errorFunction");

    errorFunctionField = new TextField(150, 100, sizex, sizey, "errorFunction", "loss", value);

    //wenn es nicht gespeichert ist
    if (F.getValue("outputFunction").length() == 0)
      value = F.getInstanceName(F, outL.outNs[0].function[0]);
    else
      value = F.getValue("outputFunction");

    outputFunctionField = new TextField(width-150-sizex, 100, sizex, sizey, "outputFunction", "outL", value);//outL.outNs[0].function
    errorFunctionField.ignore = true;
    outputFunctionField.ignore = true;

    //für textWidth()
    textSize(21);
    for (int i = 0; i < methodNames.length; i++) {

      //wenn es eine Aktivierungsfunktion ist
      if (methodTypes[i].equals("Function[]")) {

        //wenn es nicht über den Rand hinaus geht
        if (textWidth(methodNameText + ", " + methodNames[i]) < width)
          methodNameText += ", " + methodNames[i];

        //wenn noch kein "..." am Ende ist
        else if (!methodNameText.substring(methodNameText.length()-3, methodNameText.length()).equals("..."))
          methodNameText += "...";
      } else if (methodTypes[i].equals("ErrorFunction")) {

        //wenn es nicht über den Rand hinaus geht
        if (textWidth(methodNameTextError + ", " + methodNames[i]) < width)
          methodNameTextError += ", " + methodNames[i];

        //wenn noch kein "..." am Ende ist
        else if (!methodNameTextError.substring(methodNameTextError.length()-3, methodNameTextError.length()).equals("..."))
          methodNameTextError += "...";
      }
    }
    // ", " entfernen
    methodNameText = methodNameText.substring(2, methodNameText.length());
    methodNameTextError = methodNameTextError.substring(2, methodNameTextError.length());
  }

  //der String der in dem Help-Field gezeigt wird
  String helpString = "";

   public void show() {

    background(backgroundColor);

    switch(state) {

    case TRAINorSHOW:

      textSize(21);
      fill(contrast);
      stroke(30);
      rectMode(CENTER);
      int sx = 150;
      int sy = 50;
      int px = width/4;
      int py = height/2;
      rect(px, py, sx, sy);

      if (mousePressed && mouseX < px + sx/2 && mouseX > px - sx/2 && mouseY < py+sy/2 && mouseY >= py-sy/2) {

        state = States.LAYERS;

        for (int i = 0; i < layerFields.size(); i++)
          layerFields.get(i).ignore = false;

        errorFunctionField.ignore = false;
        outputFunctionField.ignore = false;
      }


      px += width/2;
      stroke(30);
      fill(contrast);
      rect(px, py, sx, sy);
      if (mousePressed && mouseX < px + sx/2 && mouseX > px - sx/2 && mouseY < py+sy/2 && mouseY >= py-sy/2) {
        showSettings();
        setup2();
        return;
      }

      //wenn das Bild geladen wurde
      if (equations != null) {

        if (visualConsole == null) {
          String[] args = {"console"};
          visualConsole = new Console();
          PApplet.runSketch(args, visualConsole);
        }

        showSettings();
        show = false;
        showConsole = true;
        if (lm == null)
          lm = new LayerManager();

        F.getEquations(equations);
        equations = null;
      }

      stroke(0);
      fill(textColor);
      textAlign(CENTER, CENTER);
      text("train AI", width/4, height/2);
      text("use AI", width/2+width/4, height/2);
      text("or drag in an image", width/2, height*0.8f);
      break;

    case LAYERS:

      rectMode(CENTER);
      pushMatrix();
      //wheel++ == scrolling
      translate(0, wheel);

      for (int t = 0; t < layerFields.size(); t++)
        layerFields.get(t).show();

      textAlign(CENTER, CENTER);
      fill(255, 100, 80);
      text("Hidden-Layers", width/2, layerOffset-20);

      popMatrix();

      fill(contrast);
      stroke(30);
      rectMode(CORNER);

      //Übersicht welche Funktionen es gibt
      rect(0, 0, width, 25);
      rect(0, 25, width, 25);

      textSize(21);
      fill(textColor);
      textAlign(LEFT, TOP);

      text("  Aktivierungsfunktionen: " + methodNameText, 0, 0);
      text("  Fehlerfunktionen: " + methodNameTextError, 0, 25);

      //Fehlerfunktion und Output-Funktion
      errorFunctionField.show();
      outputFunctionField.show();
      break;

    case VARIABLES:

      for (TextField t : text)
        t.show();
      break;

    case RUN:

      hiddenLayers = new HiddenL[layerFields.size()];

      for (TextField t : text)
        t.setValue();

      for (TextField f : layerFields)
        f.setValue();

      errorFunctionField.setValue();
      outputFunctionField.setValue();

      //start
      setup2();
      state = States.lastState(state);
    }

    if (state != States.TRAINorSHOW) {

      //Pfeile

      int px = width-sizex/4;
      int py = height-sizey/2;

      noFill();
      stroke(30);
      rectMode(CORNER);
      rect(width-sizex, height-sizey, sizex, sizey, 5);

      textAlign(CENTER, CENTER);
      textSize(60);
      fill(60, 170, 50);
      beginShape();
      vertex(px, py-2*arrowSize);
      vertex(px, py-6*arrowSize);

      //Spitze
      vertex(px+6*arrowSize, py);

      vertex(px, py+6*arrowSize);
      vertex(px, py+2*arrowSize);

      vertex(px-9*arrowSize, py+2*arrowSize);
      vertex(px-9*arrowSize, py-2*arrowSize);

      vertex(px, py-2*arrowSize);
      endShape();

      fill(170, 60, 50);

      px = width-sizex+30;
      py = floor(height-sizey/2);
      beginShape();
      vertex(px, py-2*arrowSize);
      vertex(px, py-6*arrowSize);

      //Spitze
      vertex(px-6*arrowSize, py);

      vertex(px, py+6*arrowSize);
      vertex(px, py+2*arrowSize);

      vertex(px+9*arrowSize, py+2*arrowSize);
      vertex(px+9*arrowSize, py-2*arrowSize);

      vertex(px, py-2*arrowSize);
      endShape();

      //help menu
      rectMode(CORNER);
      fill(contrast);
      stroke(20);
      rect(0, height-30, width-sizex, 30);
      textAlign(LEFT, TOP);
      //textAlign(CENTER, CENTER);

      textSize(20);
      fill(textColor);
      text(helpString, 20, height-27);
    }
  }

   public void savePanel() {

    PrintWriter w = createWriter(loadFile("data.txt"));

    for (int i = 0; i < layerFields.size(); i++)
      w.println(i + "hiddenLayers:::" + layerFields.get(i).userInput);

    w.println("outputFunction:::" + outputFunctionField.userInput);
    w.println("errorFunction:::" + errorFunctionField.userInput);


    for (TextField f : text)
      w.println(f.name + ":::" + f.userInput);
    w.flush();
    w.close();
  }

   public void stateSetup(States state) {
    if (start)return;

    switch(state) {

    case TRAINorSHOW:
    case RUN:
      for (TextField t : text)
        t.ignore = true;
      for (int t = 0; t < layerFields.size(); t++)
        layerFields.get(t).ignore = true;
      errorFunctionField.ignore = true;
      outputFunctionField.ignore = true;
      break;

    case LAYERS:
      for (TextField t : text)
        t.ignore = true;
      for (int t = 0; t < layerFields.size(); t++)
        layerFields.get(t).ignore = false;
      errorFunctionField.ignore = false;
      outputFunctionField.ignore = false;
      break;

    case VARIABLES:
      for (TextField t : text)
        t.ignore = false;
      for (int t = 0; t < layerFields.size(); t++)
        layerFields.get(t).ignore = true;
      errorFunctionField.ignore = true;
      outputFunctionField.ignore = true;
      break;
    }
  }

   public void showSettings() {

    show = true;
    train = false;
    loadWeights = true;
    saveWeights = false;
    loadExamples = false;
    saveExamples = false;
    showConsole = false;
  }


   public void mousePressed() {
    if (ignorePanel)return;

    for (TextField t : text)
      t.mousePressed();

    for (int t = 0; t < layerFields.size(); t++)
      layerFields.get(t).mousePressed();

    errorFunctionField.mousePressed();
    outputFunctionField.mousePressed();
  }

   public void mouseReleased() {
    if (ignorePanel)return;

    //wenn es der rechte Pfeil ist
    if (mouseX > width-sizex/2 && mouseX < width && mouseY > height-sizey && mouseY < height && !(start && States.getIndex(state) == States.values().length-2)) {
      state = States.nextState(state);
      stateSetup(state);
      //wenn es der linke Pfeil ist
    } else if (mouseX > width-sizex && mouseX < width-sizex/2 && mouseY > height-sizey && mouseY < height && !(start && States.getIndex(state) == 1)) {
      state = States.lastState(state);
      stateSetup(state);
    }

    for (TextField t : text)
      if (!t.TYPE.equals("boolean"))
        t.mouseReleased();
    for (int t = 0; t < layerFields.size(); t++)
      layerFields.get(t).mouseReleased();

    errorFunctionField.mouseReleased();
    outputFunctionField.mouseReleased();
  }

   public void keyTyped() {
    if (ignorePanel)return;

    for (TextField t : text)
      if (!t.TYPE.equals("boolean"))
        t.keyTyped();
    for (int t = 0; t < layerFields.size(); t++)
      layerFields.get(t).keyTyped();

    errorFunctionField.keyTyped();
    outputFunctionField.keyTyped();
  }

   public void keyReleased() {
    if (ignorePanel)return;

    for (TextField t : text)
      if (!t.TYPE.equals("boolean"))
        t.keyReleased();

    for (int t = 0; t < layerFields.size(); t++)
      layerFields.get(t).keyReleased();

    errorFunctionField.keyReleased();
    outputFunctionField.keyReleased();
  }

   public void keyPressed() {
    if (ignorePanel)return;

    for (TextField t : text)
      if (!t.TYPE.equals("boolean"))
        t.keyPressed();

    for (int t = 0; t < layerFields.size(); t++)
      layerFields.get(t).keyPressed();

    errorFunctionField.keyPressed();
    outputFunctionField.keyPressed();
  }

   public void mouseWheel(MouseEvent event) {
    if (state != States.LAYERS || ignorePanel)return;
    e = event.getCount();
    wheel += e*10;

    if (layerFields.get(layerFields.size()-1).pos.y + sizey > height)
      wheel = constrain(wheel, -layerFields.get(layerFields.size()-1).pos.y - sizey + height, 0);
    else
      wheel = 0;
  }


  class TextField {

    PVector pos, size;
    String userInput = "";
    String name = "";
    //help string wird gezeigt wenn das Feld ausgewählt ist
    String help = "";
    boolean userIsTyping = false;
    int strokeColor = color(255, 100);
    String TYPE;
    int writeIndex = 1;
    private Object value;

    <V> TextField(int px, int py, int sx, int sy, String type, String _name, V v, boolean typing) {
      this(px, py, sx, sy, type, _name, v);
      userIsTyping = typing;
    }

    <V> TextField(int px, int py, int sx, int sy, String type, String _name, V v) {

      this.TYPE = type;

      name = _name;
      for (int i = 0; i < helpDocumentation.length; i++)
        if (split(helpDocumentation[i], ":::")[0].equals(name)) {
          help = split(helpDocumentation[i], ":::")[1];
          break;
        }

      if (TYPE.equals("boolean"))
        value = Boolean.parseBoolean(v.toString());
      else
        value = v;

      // help = _help;
      pos = new PVector(px, py);
      size = new PVector(sx, sy);
      userInput = "" + v;

      if (TYPE.equals("float") || TYPE.equals("double"))
        writeIndex = userInput.length();

      if (_name.equals("momentumWeakness"))
        name = "momentum";

      textSize(21);
      noFill();
      stroke(strokeColor);
    }

    int x, y;
    //ob schon "|" gezeichnet wurde
    boolean strich;
    //damit der Strich viieel coooler ist
    boolean cool = false;
    //ob die events ignoriert werden sollen
    boolean ignore = false;
    //für einen Zyklus ignorieren, damit für eine kurze zeit die events deaktiviert werden
    boolean tempIgnore = false;

     public void show() {
      if (tempIgnore) {
        ignore = false;
        tempIgnore = false;
      }
      textSize(21);
      if (userIsTyping && !helpString.equals(help))
        helpString = this.help;

      pushMatrix();

      noFill();
      stroke(100, 100);
      rectMode(CORNER);
      rect(pos.x, pos.y, size.x, size.y, 5);
      fill(250, 100, 0);
      textAlign(LEFT, TOP);

      if (!TYPE.equals("[HiddenL"))
        text(name, pos.x + size.x/2-textWidth(name)/2, pos.y, size.x, size.y);

      fill(206, 39, 44);
      translate(size.x/2-textWidth(userInput)/2, 20);
      if (TYPE.equals("boolean"))
        text(userInput, pos.x, pos.y, size.x, size.y);

      //offset da size.y nur sizey/2, ist anstatt sizey
      else if (TYPE.equals("[HiddenL"))
        pos.y -= size.y/2;


      if (cool && !TYPE.equals("boolean")) {
        x = 0;
        y = 0;
        strich = false;

        int fadeColor = fade();
        for (int i=0; i <= userInput.length(); i++) {

          if (userIsTyping) {
            fill(fadeColor);
            if (i == writeIndex || i == userInput.length()) {
              if (i == userInput.length()) {
                if (!strich)
                  text("|", pos.x+x%(size.x-10), pos.y+y, size.x, size.y);
              } else {
                strich = true;
                text("|", pos.x+x%(size.x-10), pos.y+y, size.x, size.y);
                x += textWidth("|");
              }
            }
          }

          if (i != userInput.length()) {

            if (state == States.LAYERS) {
              String[] split =  split(userInput, ':');

              //wenn es ein hiddenLayer ist
              if (split.length == 2) {
                if (F.availibleFunction(F, split[1]))
                  fill(textColor);
                else fill (255, 0, 0);

                //wenn es eine out oder error function ist
              } else if (F.availibleFunction(F, userInput))
                fill(textColor);
              else fill(255, 0, 0);
            } else fill(textColor);

            text(str(userInput.charAt(i)), pos.x+x%(size.x-10), pos.y+y, size.x, size.y);

            x += textWidth(userInput.charAt(i));
            y = PApplet.parseInt((x/(size.x-10)))*30;
          }
        }
      } else if (!TYPE.equals("boolean")) {
        if (state == States.LAYERS) {
          String[] split =  split(userInput, ':');

          //wenn es ein hiddenLayer ist
          if (split.length == 2) {
            if (F.availibleFunction(F, split[1]))
              fill(textColor);

            //wenn es eine out oder error function ist
          } else if (F.availibleFunction(F, userInput))
            fill(textColor);
          else fill(255, 0, 0);
        } else fill(textColor);

        textAlign(LEFT, TOP);

        text(userInput, pos.x, pos.y, size.x, size.y);

        if (userIsTyping) {
          fill(fade());

          String chars;
          if (writeIndex == userInput.length())
            chars = userInput;
          else
            chars = userInput.substring(0, writeIndex);

          x = (int)textWidth(chars);
          text("|", pos.x+x-2, pos.y, size.x, size.y);
        }
      }
      if (TYPE.equals("[HiddenL"))
        pos.y += size.y/2;

      popMatrix();
    }

    boolean dark = false;
    int fadeValue = 0;

     public int fade() {
      if (keyPressed)
        return 255;
      //if(millis() %30 == 0)fadeValue = 0;
      //else fadeValue = 255;
      if (fadeValue <= 0)dark = false;
      if (fadeValue >= 255)dark = true;
      if (dark)
        fadeValue -= 4;
      else
        fadeValue += 4;

      return fadeValue;
    }

     public void updateStrokeColor() {
      if (userIsTyping) {
        strokeColor = color(255, 0, 0);
      } else {
        strokeColor = color(255);
      }
    }

     public void keyTyped() {

      if (!userIsTyping || ignore) return;
      if (textWidth(userInput)+10 >= size.x) {
        checkBackspace(1);
        return;
      }
      switch(TYPE) {
      case "long":
      case "int":
      case "char":
      case "byte":
        //vieleicht und dass der Wert nicht zu groß ist=
        if (key >= '0' && key <= '9') {
          addChar();
        }
        checkBackspace(1);

        break;
      case "double":
      case "float":
        if (((key >= '0' && key <= '9') || key == '.')) {
          addChar();
        }
        checkBackspace(1);
        break;

      case "boolean":
        break;

      case "[HiddenL":
        if (charOnSide(':', "right")) {
          if (key >= '0' && key <= '9')
            addChar();
        } else if (charOnSide(':', "left"))
          if (key >= 'a' && key <= 'z')
            addChar();

        checkBackspace(1);
        break;

      case "errorFunction":
        if ((key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z'))
          addChar();
        checkBackspace(1);
        break;

      case "outputFunction":
        if (key >= 'a' && key <= 'z')
          addChar();
        checkBackspace(1);

        break;

      default:
        if (key != CODED)
          addChar();
      }
    }

     public void checkBackspace(int amount) {
      if (key != BACKSPACE)return;

      if (TYPE.equals("[HiddenL") && layerFields.size() > 1)
        if (userInput.length() == 1) {
          if (layerFields.indexOf(this) != 0)
            layerFields.get(layerFields.indexOf(this)-1).userIsTyping = true;
          else
            layerFields.get(1).userIsTyping = true;

          //die anderen Felder sollen nachrücken
          for (int i = layerFields.indexOf(this); i < layerFields.size(); i++)
            layerFields.get(i).pos.y -= size.y;

          layerFields.remove(this);
        }

      if (userInput.length() > 0 && writeIndex > amount-1) {
        String begin = userInput.substring(0, writeIndex-amount);
        String end = userInput.substring(writeIndex, userInput.length());

        if (TYPE.equals("[HiddenL"))
          //':' darf nicht entfernt werden
          if (userInput.charAt(writeIndex-1) == ':' || userInput.equals(":"))
            return;

        userInput = begin + end;
        writeIndex -= amount;
      }
    }

     public boolean charOnSide(char c, String side) {

      if (side.equals("left")) {
        for (int i = writeIndex-1; i >= 0; i--)
          if (userInput.charAt(i) == c)
            return true;
      } else if (side.equals("right")) {
        for (int i = writeIndex; i < userInput.length(); i++)
          if (userInput.charAt(i) == c)
            return true;
      }
      return false;
    }

     public void addChar() {
      userInput = userInput.substring(0, writeIndex) + key + userInput.substring(writeIndex, userInput.length());
      if (userInput.length() == 0)
        userInput += key;
      writeIndex++;
    }

     public void keyReleased() {
      if (!userIsTyping || ignore) return;

      if (key == ENTER && TYPE.equals("[HiddenL")) {
        String value;
        if (layerFields.size() < hiddenLayers.length)
          value = hiddenLayers[layerFields.size()-1].hiddenNs.length + ":";
        else
          value = ":";

        TextField t = new TextField(PApplet.parseInt(pos.x),
          //true setzt userIsTyping auf true
          PApplet.parseInt(pos.y+size.y), (int)size.x, (int)size.y, "[HiddenL", "hiddenLayers", value, true);

        inserElement(layerFields, t, layerFields.indexOf(this));

        //damit nicht rekursiv layer hinzugefügt werden
        layerFields.get(layerFields.indexOf(this)+1).ignore = true;
        layerFields.get(layerFields.indexOf(this)+1).tempIgnore = true;

        userIsTyping = false;
      }

      int wait = millis();
      if (wait+100 < millis())
        if (key == CODED && wait >= 4) {
          if (keyCode == RIGHT) writeIndex++;
          else if (keyCode == LEFT) writeIndex--;
          wait = 0;
        }
      writeIndex = constrain(writeIndex, 0, userInput.length());
    }


     public void keyPressed() {
      if (!userIsTyping || ignore) return;

      if (key == CODED) {
        if (keyCode == RIGHT)
          writeIndex++;
        else if (keyCode == LEFT)
          writeIndex--;

        else if (TYPE.equals("[HiddenL")) {
          if (keyCode == UP && layerFields.indexOf(this)-1 >= 0) {
            layerFields.get(layerFields.indexOf(this)-1).userIsTyping = true;
            userIsTyping = false;
          }
          if (keyCode == DOWN && layerFields.indexOf(this)+1 < layerFields.size()) {
            layerFields.get(layerFields.indexOf(this)+1).userIsTyping = true;
            //damit nicht rekursiv mehr layer hinzugefügt werden
            layerFields.get(layerFields.indexOf(this)+1).tempIgnore = true;
            layerFields.get(layerFields.indexOf(this)+1).ignore = true;

            userIsTyping = false;
          }
        }
      }
      writeIndex = constrain(writeIndex, 0, userInput.length());
    }

     public void mouseReleased() {

      //easter egg
      if (mouseX < 20  && mouseY < 20)
        cool = !cool;
    }

     public void mousePressed() {

      if (ignore)return;

      if (onTextField(mouseX, mouseY)) {
        if (TYPE.equals("boolean")) {
          value = !(boolean) value;
          userInput = str((boolean) value);
        }
        userIsTyping = true;
      } else if (userIsTyping) {
        helpString = "";
        userIsTyping = false;
      }
      updateStrokeColor();
    }


     public <T> void inserElement(ArrayList<T> list, T object, int index) {

      //erstmal nur damit ein weiteres Element da ist
      list.add(object);
      for (int i = list.size()-1; i > index+1; i--) {
        list.set(i, list.get(i-1));

        //die y-Koordinate muss verändert werden
        if (list.get(i) instanceof TextField) {
          TextField field = (TextField) list.get(i);
          field.pos.y += size.y;
        }
      }
      list.set(index+1, object);
    }

     public void setValue() {

      if (name.equals("momentum"))
        name = "momentumWeakness";

      //irgendeine Variable, damit field irgendeinen Wert hat und es keine null-pointer Warnung gibt
      Field field = main.getClass().getDeclaredFields()[0];
      //Field field = null;
      try {
        field = main.getClass().getDeclaredField(name);
      }
      catch(Exception e) {
        consoleText.add("Error while setting values.");
        noLoop();
      }

      try {
        switch(TYPE) {
        case "boolean":
          //wird schon am Anfang geparsed
          field.setBoolean(main, (boolean) value);

          break;

        case "double":
          value = (Object)userInput;
          value = Double.parseDouble((value.toString()));
          field.setDouble(main, (double) value);
          break;

        case "float":
          value = (Object)userInput;
          value = PApplet.parseFloat(value.toString());
          field.setFloat(main, (float) value);

          break;

        case "long":
          value = (Object)userInput;
          value = Long.parseLong((value.toString()));
          field.setLong(main, (long) value);
          break;

        case "int":
          value = (Object)userInput;
          value = PApplet.parseInt(value.toString());
          field.setInt(main, (int) value);
          break;

        case "byte":
          value = (Object)userInput;
          value = PApplet.parseByte(PApplet.parseInt(value.toString()));
          field.setByte(main, (byte) value);
          break;

        case "errorFunction":
          loss = (ErrorFunction) F.getClass().getDeclaredField(errorFunctionField.userInput).get(F);
          break;

        case "outputFunction":
          outL = new OutputLayer(charset.length, (Function[]) F.getClass().getDeclaredField(outputFunctionField.userInput).get(F), loss);
          break;

        case "[HiddenL":

          int index = layerFields.indexOf(this);
          String[] split = split(trim(layerFields.get(index).userInput), ":");

          hiddenLayers[index] = new HiddenL(PApplet.parseInt(split[0]),
            (Function[]) F.getClass().getDeclaredField(split[1]).get(F));

          //wenn es der erste Layer ist
          if (index == 0)
            //der erste Hidden-Layer bekommt die Trainingsbeispiele
            hiddenLayers[index].createWeights(trainExampleData);
          else
            //so viele Inputs wie der Layer davor Neuronen hat
            hiddenLayers[index].createWeights(hiddenLayers[index-1].hiddenNs.length);
          break;
        }
      }
      catch (Exception e) {
        consoleText.add("error on field " + field);
        noLoop();
      }
      if (name.equals("momentumWeakness"))
        name = "momentum";
    }

     public boolean onTextField(float x, float y) {
      return (x > pos.x && x < pos.x+ + size.x &&
        y > pos.y+wheel && y < pos.y+wheel + size.y);
    }
  }
}
//Index von arraylist wo "loading x/y examples..." ist
int examplesTextIndex = -1;

class CalculatingThread extends Thread {

  float[] deltaList, deltaListPuffer, ergebnis, desired;
  int label, index;
  byte[] batch = new byte[trainExampleData];
  boolean waiting = false;

  //schon alle Trainigsbeispiele generiert
  boolean created = false;
  int id;
  float[] netzinputO;
  float[][] netzinputH, outputsH;
  //welche Beispiele schon trainiert wurden
  boolean[] trained;

  CalculatingThread(int _id) {
    int deltaListSize = 0;
    for (int i=0; i < hiddenLayers.length; i++)
      if (hiddenLayers[i].hiddenNs.length > deltaListSize)deltaListSize = hiddenLayers[i].hiddenNs.length;

    if (outL.outNs.length > deltaListSize)
      deltaListSize = outL.outNs.length;

    deltaList = new float[deltaListSize];
    deltaListPuffer = new float[deltaListSize];
    ergebnis = new float[outL.outNs.length];
    netzinputO = new float[ergebnis.length];

    outputsH = new float [hiddenLayers.length][];
    netzinputH = new float[hiddenLayers.length][];

    trained = new boolean[trainData.length];
    for (int i = 0; i < trained.length; i++)
      trained[i] = false;

    for (int i = 0; i < outputsH.length; i++) {
      outputsH[i] = new float[hiddenLayers[i].hiddenNs.length];
      netzinputH[i] = new float[outputsH[i].length];
    }

    this.id = _id;
  }

  @Override public 
    void run() {

    //die Testbeispiele erstellen
    int exampleBegin = (testExamples/threadCount)*id;
    for (int i = exampleBegin; i < exampleBegin + testExamples/threadCount; i++) {
      //wenn schon mal erstellt
      if (!F.array_null(testData[i])) continue;

      testData[i] = F.createNumber(charset[i%charset.length]);
      synchronized(generatedTestExamples) {
        generatedTestExamples++;
      }
    }

    //die Trainingsbeispiele erstellen/laden
    exampleBegin = (trainExamples/threadCount)*id;
    for (int i = exampleBegin; i < exampleBegin + trainExamples/threadCount; i++) {
      //wenn schon mal erstellt
      if (!F.array_null(trainData[i]))continue;

      if (loadExamples && i < examples.length/(trainExampleData/7))
        F.loadExample(i);
      else
        trainData[i] = F.createNumber(charset[i%charset.length]);


      labels[i] = i%charset.length;
      synchronized(generatedTrainExamples) {
        generatedTrainExamples++;
      }
      //wenn noch nicht definiert
      if (examplesTextIndex == -1)
        examplesTextIndex = consoleText.size()-1;


      if (!loadExamples || generatedTrainExamples > F.savedExamples())
        consoleText.set(examplesTextIndex, "created " + generatedTrainExamples + "/" + trainExamples + " train-examples");
      else
        consoleText.set(examplesTextIndex, "loaded " + generatedTrainExamples + "/" + trainExamples + " train-examples");
    }

    created = true;
    //warte bis das Training beginnt
    while (!start && !kill)
      delay(1);


    while (!kill && currEpoch < epochs && millis()/1000 < 60*timeOut) {

      //wenn etwas gerade geupdated wird (Fehler oder Gewichte)
      while (update)
        waiting = true;
      if (lm == null)
        println("hmmm...");
      //das Training geht zu schnell als dass der Main-Thread übersicht behalten würde
      if (currExample % batchSize == 0) {
        waiting = true;
        synchronized(lm.updateWeights) {
          //falls ein anderer Thread schon damit fertig ist
          if (currExample % batchSize == 0)
            lm.updateWeights.f();
        }
      }

      //neue Epoche
      if (currExample >= trainExamples && currEpoch < failure.length) {
        waiting = true;
        for (int i = 0; i < trained.length; i++)
          trained[i] = false;

        synchronized(lm.calcError) {
          //falls ein anderer Thread schon damit fertig ist
          if (currExample >= trainExamples && currEpoch < failure.length)
            lm.calcError.f();
        }
      }

      while (update)
        waiting = true;

      waiting = false;
      loadBatches();
      feedForward(PApplet.parseFloat(batch), label);
      backpropagation(label, index);
      currExample++;
    }
    //falls ein Thread zum Schluss noch was updated
    waiting = true;
  }

   public void loadBatches() {

    index = floor(random(trainData.length));

    //wenn dieses Beispiel in dieser Epoche bereits trainiert wurde
    if (trained[index])
      // finde das nächste nicht genutzte (rechts)
      for (int i = index+1; i < trainData.length; i++)
        if (!trained[i])
          index = i;

    if (trained[index])
      // finde das nächste nicht genutzte (links)
      for (int i = index-1; i >= 0; i--)
        if (!trained[i])
          index = i;

    //wurde schon einmal geladen
    trained[index] = true;


    batch = trainData[index];
    label = labels[index];
  }

  float netzinput_hidden;
  float netzinput_out;

   public void feedForward(float[] input, int label) {
    for (int j = 0; j < hiddenLayers.length; j++) {
      for (int i = 0; i < hiddenLayers[j].hiddenNs.length; i++) {
        netzinput_hidden            = hiddenLayers[j].hiddenNs[i].feedForward(input);
        //der output eines Neurons ist y von der Aktivierungsfunktion (f), wenn x der netzinput ist
        outputsH[j][i] = hiddenLayers[j].hiddenNs[i].function[0].f(netzinput_hidden);
        netzinputH[j][i] = netzinput_hidden;//für backpropagation
      }
      //0 da alle die gleich Aktivierungsfunktion haben
      if (hiddenLayers[j].hiddenNs[0].function.equals(F.softmax))
        //softmax ist speziell und braucht daher eine spezielle Behandlung
        //es ist zwar sowieso call by reference, ich finde die Schreibweise aber besser
        outputsH[j] = F.softmax(outputsH[j]);

      input = outputsH[j].clone();
    }
    for (int i = 0; i < outL.outNs.length; i++) {
      netzinput_out = outL.outNs[i].feedForward(input);
      //der output eines Neurons ist y von der Aktivierungsfunktion (f), wenn x der netzinput ist
      ergebnis[i]   = outL.outNs[i].function[0].f(netzinput_out);
      netzinputO[i] = netzinput_out;//für backpropagation
    }
    //0 da alle die gleich Aktivierungsfunktion haben
    if (outL.outNs[0].function.equals(F.softmax))
      //softmax ist speziell und braucht daher eine spezielle Behandlung
      ergebnis = F.softmax(ergebnis);

    if (F.max_pool_array(ergebnis) != label)
      lm.failures++;
  }

  float[] aj;//output der Neuronen des Layers davor
   public void backpropagation(int label, int inputNumber) {

    if (outL.outNs[0].function.equals(F.softmax))
      netzinputO = F.softmaxAbleitung(netzinputO);

    for (int i = 0; i < outL.outNs.length; i++) {//backpropagate out
      //die deltaList wird für die backpropagation der nächsten Schicht gebraucht
      deltaList[i] = outL.outNs[i].backward(i, label, ergebnis[i], netzinputO[i], outputsH[hiddenLayers.length-1]);
    }

    //backpropagate hidden
    for (int j = hiddenLayers.length-1; j >= 0; j--) {
      //wenn der Layer nicht nach Input kommt
      if (j != 0)  aj = outputsH[j-1].clone();
      //wenn derLayer nach Input kommt
      else  aj = PApplet.parseFloat(trainData[inputNumber].clone());

      if (hiddenLayers[j].hiddenNs[0].function.equals(F.softmax))
        netzinputH[j] = F.softmaxAbleitung(netzinputH[j]);

      for (int i = 0; i < hiddenLayers[j].hiddenNs.length; i++) {
        deltaListPuffer[i] = hiddenLayers[j].hiddenNs[i].backward(i, deltaList, netzinputH[j][i], aj, j);
      }//                        int neuronNumber, float[] deltaList, float netzinput, float[] aj, int layerNumber
      deltaList = deltaListPuffer.clone();
    }
  }
}
//normalerweise sollte es 784 sein
int trainExampleData;
float[] failure;
//byte, da es in diesem Beispiel nur 0 und 1 gibt
byte[][] trainData, testData;

//byte da labels nur von 0-9 sind
int[] labels;
//all characters a loaded font will have
final char[] charset = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '=', '+', '-'};
//zu viele "komische" dabei
//String[] fontNames = PFont.list();

String[] fontNames = {
  "Manjari Regular",
  "MathJax_SansSerif-Bold",
  "Laksaman Bold",
  "L M Sans Demi Cond10 Regular",
  "L M Mono Lt10 Regular",
  "Tlwg Typist Bold Oblique",
  "LMRomanSlant10-Bold",
  "Tlwg Typewriter Bold Oblique",
  "FreeMono Bold",
  "Tlwg Typewriter Bold Oblique",
  "Karumbi Regular",
  "Purisa",
  "LMMono10-Italic",
  "Kinnari Bold Italic",
  "Standard Symbols PS",
  "Gayathri Regular",
  "LMSans10-BoldOblique",
  "Ubuntu Light",
  "L M Roman10 Bold Italic",
  "LMMonoCaps10-Regular",
  "LMSans10-Oblique",
  "Purisa Bold Oblique",
};

CalculatingThread[] threads;

//Objekt da für synchronized
Integer generatedTrainExamples = 0;
Integer generatedTestExamples = 0;
//wird nur benutzt wenn diese aus der examples.txt Datei gelesen werden
byte[] examples;

class LayerManager {
  float[] deltaList, ergebnis, desired;
  float[][] outputsH;
  int failures = 0;

  LayerManager() {

    if (trainExamples <= 1) {
      consoleText.add("Die angegebene Anzahl an Trainingsbeispielen ist ungültig");
      kill = true;
      noLoop();
    }

    outL = new OutputLayer(charset.length, outL.outNs[0].function, outL.outNs[0].error);

    trainExampleData = F.createNumber('0').length;

    //negative lr (-> siehe Ableitung der Backpropagation)
    lr = -lr;

    //wenn nicht schon erstellt
    if (testData == null)
      testData = new byte [testExamples][trainExampleData];
    if (labels == null)
      labels = new int[trainExamples];
    failure = new float[epochs];

    if (train) {
      if (loadExamples && examples == null)
        examples = loadBytes(loadFile("examples.txt"));


      threads = new CalculatingThread[threadCount];
      if (trainData == null)
        trainData = new byte [trainExamples][trainExampleData];

      start = false;
      for (int i = 0; i < threadCount; i++)
      try {
        threads[i] = new CalculatingThread(i);
        threads[i].start();
        threads[i].setPriority(threadPriority);
      }
      catch(IllegalThreadStateException e) {
        consoleText.add("Ein Fehler ist bei dem Starten des " + i + "ten Thrads aufgetreten:");
        e.printStackTrace();
      }

      //die Threads beginnen mit dem erstellen von Beispielen
      if (testExamples > 0)
        consoleText.add("Erstelle Testbeispiele...");

      //solange noch Trainingsbeispiele erstellt werden
      while (generatedTrainExamples != trainExamples) {
        int created = 0;
        //ob alle Threads fertig sind
        for (int i=0; i < threads.length; i++) {
          if (threads[i].created)
            created++;
        }

        //falls etwas schief gegangen ist und die Threads "fertig" sind aber noch einige Beispiele fehlen
        if (created == threadCount && generatedTrainExamples != trainExamples)
          for (int i = generatedTrainExamples; i < trainExamples; i++) {

            //if (!F.array_null(trainData[i])) continue;

            if (loadExamples && i < examples.length/(trainExampleData/7))
              loadExample(i);
            else
              trainData[i] = F.createNumber(charset[i%charset.length]);

            labels[i] = i%charset.length;
            generatedTrainExamples++;
            if (!loadExamples)
              consoleText.set(examplesTextIndex, "created " + generatedTrainExamples + "/" + trainExamples + " examples");
            else
              consoleText.set(examplesTextIndex, "loaded " + generatedTrainExamples + "/" + trainExamples + " examples");
          }
      }

      //große Ressourcen löschen die nicht mehr gebraucht werden
      if (!saveExamples) {
        examples = null;
        System.gc();
      }
      //der Fehler wird nie 200% sein, es ist also ein Signal dass das Training unterbrochen wurde
      for (int i=0; i < failure.length; i++)
        failure[i] = 2;

      if (saveExamples)
        saveExamples();
    }

    if (!train)
      loadWeightsLayers();

    for (int i = hiddenLayers.length-1; i >= 0; i--) {
      //wenn es der erste Layer ist
      if (i == 0)
        //der erste Hidden-Layer bekommt die Trainingsbeispiele
        hiddenLayers[i].createWeights(trainExampleData);
      else
        //so viele Inputs wie der Layer davor Neuronen hat
        hiddenLayers[i].createWeights(hiddenLayers[i-1].hiddenNs.length);
    }

    if (loadWeights) {
      loadWeights();
      consoleText.add("weights are loaded");
    } else {
      setWeightsRandom();
      consoleText.add("weights set");
    }

    int size = 0;
    for (int i = 0; i < hiddenLayers.length; i++) {
      HiddenN[] a = hiddenLayers[i].hiddenNs;
      if (a.length > size)
        size = a.length;
    }

    //wie viele Neuronen hat die größte Schicht
    int deltaListSize = 0;
    for (int i=0; i < hiddenLayers.length; i++)
      if (hiddenLayers[i].hiddenNs.length > deltaListSize)
        deltaListSize = hiddenLayers[i].hiddenNs.length;

    if (outL.outNs.length > deltaListSize)
      deltaListSize = outL.outNs.length;

    deltaList = new float[deltaListSize];
    ergebnis = new float[outL.outNs.length];
    outputsH = new float [hiddenLayers.length][];
    for (int i = 0; i < outputsH.length; i++)
      outputsH[i] = new float[hiddenLayers[i].hiddenNs.length];
  }


   public void feedForward(float[] input) {

    for (int j = 0; j < hiddenLayers.length; j++) {
      for (int i = 0; i < hiddenLayers[j].hiddenNs.length; i++)
        outputsH[j][i] = hiddenLayers[j].hiddenNs[i].function[0].f(
          hiddenLayers[j].hiddenNs[i].feedForward(input));

      //0 da alle die gleich Aktivierungsfunktion haben
      if (hiddenLayers[j].hiddenNs[0].function.equals(F.softmax))
        //softmax ist speziell und braucht daher eine spezielle Behandlung
        F.softmax(outputsH[j]);

      input = outputsH[j].clone();
    }

    for (int i = 0; i < outL.outNs.length; i++)
      ergebnis[i] = outL.outNs[i].function[0].f(
        outL.outNs[i].feedForward(input));

    //0 da alle die gleich Aktivierungsfunktion haben
    if (outL.outNs[0].function.equals(F.softmax))
      //softmax ist speziell und braucht daher eine spezielle Behandlung
      F.softmax(ergebnis);

    consoleText.add("--Ergebnis--");
    for (int i = 0; i < ergebnis.length; i++)
      consoleText.add(floor(ergebnis[i]*100) + " % eine " + charset[i]);

    consoleText.add("-----------\n" + charset[PApplet.parseInt(F.max_pool_array(ergebnis))]);
  }

   public void test() {

    consoleText.add("testing...");
    if (loadExamples)
      examples = loadBytes(loadFile("examples.txt"));

    if (examples.length == 0)
      loadExamples = false;

    //falls noch ein Beispiel fehlt, soll es erstellt werden
    for (int i = generatedTestExamples; i < testData.length; i++)
      if (!loadExamples || i >= testData.length)
        testData[i] = F.createNumber(charset[i%charset.length]);
      else {

        //ein Trainingsbeispiel  (examples.length*7)/trainExampleData
        for (int j=0; j < trainExampleData/7; j++) {
          String bits = F.Bytes2Bits(examples[(i*trainExampleData/7)+j]);
          for (int k = 0; k < 7; k++)
            //den char in einen byte convertieren
            testData[i][j*7+k] = PApplet.parseByte(PApplet.parseInt(str(bits.charAt(k))));
        }
      }

    //werden nicht mehr gebraucht
    fontNames = null;
    System.gc();

    int errors = 0;
    float[] input;

    for (int t = 0; t < testData.length; t++) {
      input = PApplet.parseFloat(testData[t]);

      for (int j = 0; j < hiddenLayers.length; j++) {
        for (int i = 0; i < hiddenLayers[j].hiddenNs.length; i++)
          outputsH[j][i] = hiddenLayers[j].hiddenNs[i].function[0].f(
            hiddenLayers[j].hiddenNs[i].feedForward(input));

        //0 da alle die gleich Aktivierungsfunktion haben
        if (hiddenLayers[j].hiddenNs[0].function.equals(F.softmax))
          //softmax ist speziell und braucht daher eine spezielle Behandlung
          F.softmax(outputsH[j]);

        input = outputsH[j].clone();
      }
      for (int i = 0; i < outL.outNs.length; i++)
        ergebnis[i]   = outL.outNs[i].function[0].f(
          outL.outNs[i].feedForward(input));

      //0 da alle die gleich Aktivierungsfunktion haben
      if (outL.outNs[0].function.equals(F.softmax))
        //softmax ist speziell und braucht daher eine spezielle Behandlung
        F.softmax(ergebnis);

      if (F.max_pool_array(ergebnis) != t%charset.length)
        errors++;
    }
    consoleText.add("Durchschnittlicher Fehler nach dem Training: " + errors/1.0f/testData.length);
  }

  //Functional Interfaces, damit die Funktion auch als Lock benutzt werden kann (synchronized)
  ErrorFunction  updateWeights = x -> {

    update = true;
    for (int i=0; i < threads.length; i++)
      while (!threads[i].waiting)
        delay(1);

    for (int j=0; j < hiddenLayers.length; j++)
      for (int i = 0; i < hiddenLayers[j].hiddenNs.length; i++)
        //das von den Threads berechnete Delta der Gewichte hinzufügen
        hiddenLayers[j].hiddenNs[i].applyBatch();

    for (int i = 0; i < outL.outNs.length; i++)
      outL.outNs[i].applyBatch();
    update = false;
    return 0;
  };

  ErrorFunction calcError = x -> {

    update = true;
    for (int i=0; i < threads.length; i++)
      while (!threads[i].waiting)
        delay(1);

    consoleText.add("Error of epoch " + currEpoch +": " + failures/1.0f/currExample);
    failure[currEpoch] = failures/1.0f/currExample;
    failures = 0;
    currExample = 0;
    currEpoch++;

    update = false;
    return 0;
  };

   public void show() {
    if (spacePressed)
      return;

    background(0);
    if (scale != 1) {
      translate(width/2, height/2);
      scale(scale);
      translate(-width/2, -height/2);
    }
    //update
    nv.show();
    textSize(22);
    fill(255);
    textAlign(CORNER);
    text("Sekunden seit Start: " + millis()/1000, width-textWidth("Sekunden seit Start: " + millis()/1000)-20, height-30);
  }


  float n = 0;
  float factor = 0.1f;

   public void setWeightsNosie() {

    if (loadWeights) return;
    for (int k=0; k < hiddenLayers.length; k++) {
      //reset hiddenWeights with noise
      for (int j = 0; j < hiddenLayers[k].hiddenNs.length; j++) {
        for (int i = 0; i < hiddenLayers[k].hiddenNs[j].weights.length; i++) {
          hiddenLayers[k].hiddenNs[j].weights[i] = map(noise(n), 0, 1, -weigthsValue, weigthsValue);
          n += factor;
        }
        hiddenLayers[k].hiddenNs[j].bias = map(noise(n), 0, 1, -weigthsValue, weigthsValue);
        n += factor;
      }
    }

    for (int j = 0; j < outL.outNs.length; j++) {//reset outWeights mit noise
      for (int i = 0; i < outL.outNs[j].weightsOH.length; i++) {
        outL.outNs[j].weightsOH[i] = map(noise(n), 0, 1, -weigthsValue, weigthsValue);
        n += factor;
      }
      outL.outNs[j].bias = map(noise(n), 0, 1, -weigthsValue, weigthsValue);
      n += factor;
    }

    for (int i=0; i < hiddenLayers.length; i++) {//reset momentum für hidden
      for (int j=0; j <  hiddenLayers[i].hiddenNs.length; j++) {
        hiddenLayers[i].hiddenNs[j].momentum = 0;
      }
    }
    for (int i=0; i < outL.outNs.length; i++) {//reset momentum für output
      outL.outNs[i].momentum = 0;
    }
  }

   public void setWeightsRandom() {
    for (int k=0; k < hiddenLayers.length; k++) {
      //reset hiddenWeights with noise
      for (int j = 0; j < hiddenLayers[k].hiddenNs.length; j++) {
        for (int i = 0; i < hiddenLayers[k].hiddenNs[j].weights.length; i++)
          hiddenLayers[k].hiddenNs[j].weights[i] = random(-weigthsValue, weigthsValue);

        hiddenLayers[k].hiddenNs[j].bias =  random(-weigthsValue, weigthsValue);
      }
    }

    for (int j = 0; j < outL.outNs.length; j++) {//reset outWeights with noise
      for (int i = 0; i < outL.outNs[j].weightsOH.length; i++)
        outL.outNs[j].weightsOH[i] = random(-weigthsValue, weigthsValue);

      outL.outNs[j].bias =  random(-weigthsValue, weigthsValue);
    }

    for (int i=0; i < hiddenLayers.length; i++) //reset momentum for hidden
      for (int j=0; j <  hiddenLayers[i].hiddenNs.length; j++)
        hiddenLayers[i].hiddenNs[j].momentum = 0;

    for (int i=0; i < outL.outNs.length; i++) //reset momentum für output
      outL.outNs[i].momentum = 0;
  }

   public void saveWeights() {
    PrintWriter w = createWriter("weights.txt");

    for (int i = 0; i < hiddenLayers.length; i++) {//für jeden Hiddenlayer
      for (int j = 0; j < hiddenLayers[i].hiddenNs.length; j++) {//für jedes Neuron
        for (int k = 0; k < hiddenLayers[i].hiddenNs[j].weights.length; k++) {//für jedes Gewicht
          w.println(hiddenLayers[i].hiddenNs[j].weights[k]);
        }
        w.println(hiddenLayers[i].hiddenNs[j].bias);
      }
    }

    for (int j = 0; j < outL.outNs.length; j++) {
      for (int k = 0; k < outL.outNs[j].weightsOH.length; k++) {
        w.println(outL.outNs[j].weightsOH[k]);
      }
      w.println(outL.outNs[j].bias);
    }
    w.println("---Info---");
    w.println(trainExampleData + " Inputs");
    for (int i = 0; i < hiddenLayers.length; i++)
      w.println("Hidden-Layer " + i + " hat " + hiddenLayers[i].hiddenNs.length +" Neuronen:" +
        F.getInstanceName(F, hiddenLayers[i].hiddenNs[0].function[0]));


    w.println(outL.outNs.length + " Output-Neuronen:" + F.getInstanceName(F, outL.outNs[0].function[0]));
    w.flush();
    w.close();
    println("save");
  }

   public void loadWeights() {

    String[] weights = loadStrings(loadFile("weights.txt"));

    try {
      int iterator = 0;
      for (int i = 0; i < hiddenLayers.length; i++) {//für jeden Hiddenlayer
        for (int j = 0; j < hiddenLayers[i].hiddenNs.length; j++) {//für jedes Neuron
          for (int k = 0; k < hiddenLayers[i].hiddenNs[j].weights.length; k++) {//für jedes Gewicht
            hiddenLayers[i].hiddenNs[j].weights[k] = PApplet.parseFloat(weights[iterator]);
            iterator++;
          }
          hiddenLayers[i].hiddenNs[j].bias = PApplet.parseFloat(weights[iterator]);
          iterator++;
        }
      }

      for (int i = 0; i < outL.outNs.length; i++) {
        for (int j = 0; j < outL.outNs[i].weightsOH.length; j++) {
          outL.outNs[i].weightsOH[j] = PApplet.parseFloat(weights[iterator]);
          iterator++;
        }
        outL.outNs[i].bias = PApplet.parseFloat(weights[iterator]);
        iterator++;
      }
    }
    catch (Exception e) {
      consoleText.add("Die angegebenen Gewichte in der Datei weights.txt passen nicht zu den im Programm angegebenen Layern und ihren Neuronen.");
      consoleText.add("Eine Angabe für wie viele Layer und Neuronen die Gewichte gedacht sind findet sich am Ende der Datei weights.txt:");

      //index der Info
      int index = 0;
      for (int i = weights.length-1; i >= 0; i--)
        if (weights[i].equals("---Info---"))
          index = i;

      for (int i = index; i < weights.length; i++)
        consoleText.add(weights[i]);

      noLoop();
    }
  }

   public void loadWeightsLayers() {

    String[] weights = loadStrings(loadFile("weights.txt"));
    //index der Info
    int index = 0;
    for (int i = weights.length-1; i >= 0; i--)
      if (weights[i].equals("---Info---"))
        index = i;

    /*
     Beispiel:
     ---Info---
     1600 Inputs
     Hidden-Layer 0 hat 12 Neuronen:relu
     Hidden-Layer 1 hat 10 Neuronen:relu
     10 Output-Neuronen:sigmoid
     */

    //skip das Unwichtige
    index += 2;
    hiddenLayers = new HiddenL[weights.length-(index+1)];
    Function[] f;
    try {

      for (int i = 0; i < hiddenLayers.length; i++) {
        f = (Function[]) F.getClass().getDeclaredField(split(weights[index+i], ':')[1]).get(F);
        int neurons = PApplet.parseInt(split(split(weights[index+i], "hat ")[1], ' ')[0]);
        hiddenLayers[i] = new HiddenL(neurons, f);
      }
      f = (Function[]) F.getClass().getDeclaredField(split(weights[weights.length-1], ':')[1]).get(F);
      //loss muss nicht aktualisiert werden, da nicht trainiert wird
      outL = new OutputLayer(charset.length, f, loss);
    }
    catch (NoSuchFieldException | IllegalAccessException e) {
      consoleText.add("Die in der Info von weigts.txt angegebene Funktion existiert nicht mehr.");
      noLoop();
    }
  }

   public void saveExamples() {

    //wenn z.B. schon 200 gespeichert sind und trainExamples = 50 ist,
    //sollen die 150 übrig bleibenden nicht gelöscht werden
    if (loadExamples && trainExamples <= examples.length/(trainExampleData/7))
      return;

    PrintWriter w = createWriter("examples.txt");

    //die Beispiele werden hier auf eine einfache Art und Weise kodiert.
    //Man könnte später noch bessere (und kompliziertere) Verfahren wie die Huffman-Kodierung
    for (int i=0; i < trainExamples; i++) {
      for (int j=0; j < trainExampleData; j += 7) {
        //sollte das Beispiel nicht schon gespeichert sein
        if (loadExamples && i*(trainExampleData/7)+trainExampleData/7 < examples.length) {
          for (int jindx=0; jindx < trainExampleData/7; jindx++)
            w.print(PApplet.parseChar(examples[i*(trainExampleData/7)+jindx]));
          break;
        } else {
          //chars haben 0 bis einschließlich 65535 == 2^16. ASCII hat 0-einschließlich 127, also 2^7

          String b = "";
          for (int k = 0; k  < 7; k++)
            b += trainData[i][j+k];
          w.print(PApplet.parseChar(F.bits2Bytes(b)));
        }
      }
    }
    w.flush();
    w.close();
  }

   public void loadExample(int index) {

    //ein Trainingsbeispiel  (examples.length*7)/trainExampleData
    for (int j=0; j < trainExampleData/7; j++) {
      String bits = F.Bytes2Bits(examples[(index*trainExampleData/7)+j]);
      for (int k = 0; k < 7; k++)
        //den char in einen byte convertieren
        trainData[index][j*7+k] = PApplet.parseByte(PApplet.parseInt(str(bits.charAt(k))));
    }
  }
}
class NeuronalNetworkVisualization {

  //size der Neuronen
  int size = 50;
  //wie hell die Gewichte sein sollen
  int alpha = 1500;
  long countdown = 0;
  //ob er mit der Animation fertig ist oder nicht
  boolean finished = false;
  //Positionen der Neuronen
  PVector[][] pos;
  //Processing Graphic
  PGraphics pg;
  NeuronalNetworkVisualization(int x, int y) {
    pg = createGraphics(x, y);

    // +2 für out und input Layer
    pos = new PVector[hiddenLayers.length+2][];

    pos[0] = new PVector[trainExampleData];
    for (int i=0; i < hiddenLayers.length; i++)
      pos[i+1] = new PVector[hiddenLayers[i].hiddenNs.length];

    pos[pos.length-1] = new PVector[outL.outNs.length];

    //Vectoren erstellen
    for (int i = 0; i < pos.length; i++)
      for (int j = 0; j < pos[i].length; j++)
        pos[i][j] = new PVector();

    calculatePosition();
  }

   public void show() {
    if (spacePressed)
      return;

    pg.beginDraw();
    pg.background(0);
    drawConnections(5);
    drawEllipses();
    pg.endDraw();

    background(0);
    image(pg, offset, 0);
  }

  boolean drawedConnections = false;
  int offset = 100;

   public void showResult() {

    if (spacePressed)
      return;

    //ob er mit der Animation fertig ist oder nicht
    if (finished) {
      //5 Sekunden nach dem die Animation fertig ist
      if (millis() >= countdown+3000 && countdown != 0) {
        background(0);
        int iterator = 0;
        for (int i=0; i < lm.ergebnis.length; i++) {
          if (lm.ergebnis[i] == max(lm.ergebnis)) {
            fill(255);
            textSize(60);
            textAlign(CENTER, CENTER);
            text(charset[i], width/2, height/2-100);
            textSize(15);
            text(str(lm.ergebnis[i]*100)+'%', width/2, height/2-50);
          } else {
            fill(155);
            textSize(20);
            textAlign(LEFT, CENTER);
            text(charset[i], width/(lm.ergebnis.length-1)*iterator+10, height/2+100);
            textSize(13);

            String s = str(lm.ergebnis[i]*100);
            //wenn er zu viele Stellen hat
            if (s.length() > 10)
              s = s.substring(0, s.length()-5) + s.substring(s.length()-4, s.length());

            s+= '%';
            text(s, width/(lm.ergebnis.length-1)*iterator+10, height/2+120);
            iterator++;
          }
        }
        fill(5);
        stroke(255);
        textAlign(CENTER, CENTER);
        rectMode(CENTER);
        int w = 2*PApplet.parseInt(textWidth("again?"));
        int h = 30;
        int px = width-w/2-10;
        int py = height-h/2-10;
        rect(px, py, w, h);
        fill(255);
        text("again?", px, py);
        //if mouse in rect
        if (mousePressed && mouseX > px-w/2 && mouseX < px+w/2 && mouseY > py-h/2 && mouseY < py+h/2) {
          //reset to setup
          finishedDrawing = false;
          digit.allOutOfScreen = false;
          finished = false;
          drawedConnections = false;
          //clear
          countdown = 0;
          brightness = 0;
          for (int i=0; i <  lm.ergebnis.length; i++) lm.ergebnis[i] = 0;
          for (int j=0; j < hiddenLayers.length; j++) {
            for (int i=0; i < hiddenLayers[j].hiddenNs.length; i++) {
              hiddenLayers[j].hiddenNs[i].summe[0] = 0;
            }
          }
          pg.beginDraw();
          //reset fill
          drawLmEllipses();
          pg.endDraw();
          background(0);
          surface.setVisible(false);
          digit.setDigitLocation(displayWidth/2-digit.width, displayHeight/2-digit.height);
        }

        fill(backgroundColor);
        stroke(0);
        textAlign(CENTER, CENTER);
        rectMode(CENTER);
        textSize(60);
        w = 75;
        h = 60;
        px = w/2-10;
        py = height-h/2-10;
        rect(px, py, w, h);

        fill(170, 60, 50);

        beginShape();
        vertex(px, py-2*arrowSize);
        vertex(px, py-6*arrowSize);

        //Spitze
        vertex(px-6*arrowSize, py);

        vertex(px, py+6*arrowSize);
        vertex(px, py+2*arrowSize);

        vertex(px+9*arrowSize, py+2*arrowSize);
        vertex(px+9*arrowSize, py-2*arrowSize);

        vertex(px, py-2*arrowSize);
        endShape();

        if (mousePressed && mouseX > px-w/2 && mouseX < px+w/2 && mouseY > py-h/2 && mouseY < py+h/2)
          digit.exit();

        //mach einfach irgendwas
      } else if (millis()%7 == 0) {
        loadPixels();
        for (int i=0; i < pixels.length; i++)
          pixels[i] += 8;
        updatePixels();
      }
      return;
    }
    if (!drawedConnections) {
      pg.beginDraw();
      pg.background(0);
      drawConnections(1);
      drawLmEllipses();
      pg.endDraw();
      drawedConnections = true;

      background(0);
      image(pg, offset, 0);
      showText();
    } else {
      pg.beginDraw();
      drawLmEllipses();
      pg.endDraw();

      background(0);
      image(pg, offset, 0);
      showText();
    }
  }

   public void showText() {

    float decision = max(lm.ergebnis);
    textSize(11);
    //j == Neuronenindex
    textAlign(LEFT, CENTER);
    int j = 0;
    for (int i =0; i <  outL.outNs.length; i++) {

      if (lm.ergebnis[j] == decision) fill(190);
      else fill(70);
      text(lm.ergebnis[j], pos[pos.length-1][i].x + 140, pos[pos.length-1][i].y);
      j++;
    }
  }

   public void drawConnections(int fastDraw) {
    //show connections von dem hidden Neuron zu dem input/hidden
    for (int j=0; j < hiddenLayers.length; j++) {
      for (int i=0; i < hiddenLayers[j].hiddenNs.length; i++) {
        for (int k=0; k < pos[j].length; k++) {
          //um schneller zu sein, ein paar Gewichte auslassen
          if (j == 0 && k%fastDraw != 0)
            continue;
          if (hiddenLayers[j].hiddenNs[i].weights[k] > 0) pg.stroke(0, 255, 0, hiddenLayers[j].hiddenNs[i].weights[k] * alpha);
          else pg.stroke(255, 0, 0, hiddenLayers[j].hiddenNs[i].weights[k] *-alpha);
          pg.line(pos[j+1][i].x, pos[j+1][i].y, pos[j][k].x, pos[j][k].y);
        }
      }
    }
    //show connections von den output Neuronen zu dem letzten hidden layer
    for (int i=0; i < outL.outNs.length; i++) {
      for (int k=0; k <pos[pos.length-2].length; k++) {
        if (outL.outNs[i].weightsOH[k] > 0)pg.stroke(0, 255, 0, outL.outNs[i].weightsOH[k] * alpha);
        else pg.stroke(255, 0, 0, outL.outNs[i].weightsOH[k] * -alpha);
        pg.line(pos[pos.length-1][i].x, pos[pos.length-1][i].y, pos[pos.length-2][k].x, pos[pos.length-2][k].y);
      }
    }
  }

   public void drawEllipses() {
    //show input Layer
    size = (pg.height-2*20)/trainExampleData;
    size = constrain(size, 1, 50);
    pg.stroke(200);
    for (int i=0; i < trainExampleData; i++) {
      pg.fill(trainData[threads[0].index][i]*10);
      pg.ellipse(pos[0][i].x, pos[0][i].y, size, size);
    }

    //show hidden Layers
    for (int j=0; j < hiddenLayers.length; j++) {

      size = (pg.height-2*20)/hiddenLayers[j].hiddenNs.length;
      size = constrain(size, 1, 50);
      for (int i=0; i < hiddenLayers[j].hiddenNs.length; i++) {
        pg.fill(hiddenLayers[j].hiddenNs[i]. summe[0] * 100);
        pg.ellipse(pos[j+1][i].x, pos[j+1][i].y, size, size);
      }
    }
    size = (pg.height-2*20)/outL.outNs.length;
    size = constrain(size, 1, 50);
    //show output Layer
    for (int i=0; i < outL.outNs.length; i++) {
      pg.fill(threads[0].ergebnis[i] * 250);
      pg.ellipse(pos[pos.length-1][i].x, pos[pos.length-1][i].y, size, size);
    }
  }
  int maxColor = 100;
  int brightness = 0;

   public void drawLmEllipses() {
    //show input Layer
    //wenn drawedConnections false ist, ist es das erste Mal dass die Methode aufgerufen wird
    if (digit.pigments.size() != 0 && drawedConnections) return;
    size = (pg.height-2*20)/trainExampleData;
    size = constrain(size, 1, 50);
    pg.stroke(200);
    for (int i=0; i < trainExampleData; i++) {
      pg.fill(digit.example[i]*100);
      pg.ellipse(pos[0][i].x, pos[0][i].y, size, size);
    }

    //show hidden Layers
    for (int j=0; j < hiddenLayers.length; j++) {
      size = (pg.height-2*20)/hiddenLayers[j].hiddenNs.length;
      size = constrain(size, 1, 50);
      for (int i=0; i < hiddenLayers[j].hiddenNs.length; i++) {
        pg.fill(hiddenLayers[j].hiddenNs[i].summe[0] * brightness);
        pg.ellipse(pos[j+1][i].x, pos[j+1][i].y, size, size);
      }
    }
    if (brightness < maxColor)
      brightness += 5;
    if (brightness != maxColor && drawedConnections)
      return;

    size = (pg.height-2*20)/outL.outNs.length;
    size = constrain(size, 1, 50);
    //show output Layer
    for (int i=0; i < outL.outNs.length; i++) {
      if (drawedConnections)
        pg.fill(lm.ergebnis[i] * 250);
      pg.ellipse(pos[pos.length-1][i].x, pos[pos.length-1][i].y, size, size);
    }
    if (!drawedConnections)
      return;
    finished = true;
    countdown = millis();
  }

   public void calculatePosition() {
    int currentLayer = 0;
    int y;
    //calculate input Layer
    size = (pg.height-2*20)/trainExampleData;
    size = constrain(size, 1, 50);

    int iterator = 0;
    for (int i = trainExampleData-1; i >= 0; i--) {
      y = pg.height/2 + trainExampleData/2 * size -i*size -size/2;
      if (trainExampleData % 2 != 0)
        y += size/2;

      pos[0][iterator].x = pg.width/(hiddenLayers.length+2)*currentLayer + size;
      pos[0][iterator].y = y;
      iterator++;
    }
    currentLayer++;
    size = 50;
    iterator = 0;
    //calculate hidden Layers
    for (int j = 0; j < hiddenLayers.length; j++) {
      size = (pg.height-2*20)/hiddenLayers[j].hiddenNs.length;
      size = constrain(size, 1, 50);
      for (int i=hiddenLayers[j].hiddenNs.length-1; i >= 0; i--) {
        y = pg.height/2 + hiddenLayers[j].hiddenNs.length/2 * size -i*size -size/2;
        if (hiddenLayers[j].hiddenNs.length% 2 != 0)
          y += size/2;

        pos[j+1][iterator].x = pg.width/(hiddenLayers.length+2)*currentLayer+size;
        pos[j+1][iterator].y = y;
        iterator++;
      }
      currentLayer++;
      iterator = 0;
    }

    size = (pg.height-2*20)/outL.outNs.length;
    size = constrain(size, 1, 50);
    //calculate output Layer
    for (int i= outL.outNs.length-1; i >= 0; i--) {
      y = pg.height/2 + outL.outNs.length/2 * size -i*size - size/2;
      if (outL.outNs.length% 2 != 0)
        y += size/2;

      pos[pos.length-1][iterator].x = pg.width/(hiddenLayers.length+2)*currentLayer + size;
      pos[pos.length-1][iterator].y = y;
      iterator++;
    }
  }
}


  public void settings() { size(1000, 300); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Neuronales_Netz" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
